
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeetCode | scola的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="LeetCode最近在学习python3，便想到了用python3刷LeetCode，既可以学习到python3的一些语法细节，也可以锻炼算法能力。 刷题未完全按照LeetCode排列顺序去刷，但是排布会按照题号大小去排列。算法小白，大佬看到勿喷。">
<meta name="keywords" content="LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode">
<meta property="og:url" content="http:&#x2F;&#x2F;139.180.173.25&#x2F;2019&#x2F;11&#x2F;06&#x2F;LeetCode&#x2F;index.html">
<meta property="og:site_name" content="scola的博客">
<meta property="og:description" content="LeetCode最近在学习python3，便想到了用python3刷LeetCode，既可以学习到python3的一些语法细节，也可以锻炼算法能力。 刷题未完全按照LeetCode排列顺序去刷，但是排布会按照题号大小去排列。算法小白，大佬看到勿喷。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-11-07T09:31:47.937Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="scola的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">scola的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="139.180.173.25">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-LeetCode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/06/LeetCode/" class="article-date">
  <time datetime="2019-11-06T01:50:19.000Z" itemprop="datePublished">2019-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeetCode
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
		<!-- Table of Contents -->
		
  		  <div id="toc" class="toc-article">
   		    <strong class="toc-title">文章目录</strong>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">1.</span> <span class="toc-text">LeetCode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.1.</span> <span class="toc-text">1.两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.2.</span> <span class="toc-text">2.两数相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.3.</span> <span class="toc-text">3.无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.4.</span> <span class="toc-text">5. 最长回文子串-动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.5.</span> <span class="toc-text">7. 整数反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.6.</span> <span class="toc-text">8. 字符串转换整数 (atoi)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.7.</span> <span class="toc-text">9. 回文数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.8.</span> <span class="toc-text">13. 罗马数字转整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.9.</span> <span class="toc-text">14. 最长公共前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.10.</span> <span class="toc-text">20.有效的括号-栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.11.</span> <span class="toc-text">21. 合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.12.</span> <span class="toc-text">53. 最大子序和-动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.13.</span> <span class="toc-text">55.跳跃游戏-贪婪算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.14.</span> <span class="toc-text">62. 不同路径-动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.15.</span> <span class="toc-text">63.不同路径II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.16.</span> <span class="toc-text">64. 最小路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.17.</span> <span class="toc-text">70. 爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.18.</span> <span class="toc-text">71.简化路径-栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.19.</span> <span class="toc-text">94.二叉树的中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.20.</span> <span class="toc-text">122.买卖股票的最佳时机 II-贪婪算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.21.</span> <span class="toc-text">134.加油站-贪婪算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.22.</span> <span class="toc-text">215.数组中的第K个最大元素-堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.23.</span> <span class="toc-text">264.丑数II-堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.24.</span> <span class="toc-text">313.超级丑数-堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.25.</span> <span class="toc-text">347.前 K 个高频元素-堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.26.</span> <span class="toc-text">376.摆动序列-贪婪算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.27.</span> <span class="toc-text">392.判断子序列-贪婪算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.28.</span> <span class="toc-text">402.移掉K位数字-贪婪算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.29.</span> <span class="toc-text">455.分发饼干-贪婪算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.30.</span> <span class="toc-text">703.数据流中的第K大元素-堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.31.</span> <span class="toc-text">1021.删除最外层的括号-栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.32.</span> <span class="toc-text">1047.删除字符串中的所有相邻重复项-栈</span></a></li></ol></li></ol>[object Object]
          </div>
        
        <h2><span id="leetcode">LeetCode</span></h2><p>最近在学习python3，便想到了用python3刷LeetCode，既可以学习到python3的一些语法细节，也可以锻炼算法能力。</p>
<p>刷题未完全按照LeetCode排列顺序去刷，但是排布会按照题号大小去排列。算法小白，大佬看到勿喷。</p>
<a id="more"></a>

<h3><span id="1-liang-shu-zhi-he">1.两数之和</span></h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]</p>
<p>执行用时 :64 ms, 在所有 python3 提交中击败了93.62%的用户<br>        内存消耗 :15.5 MB, 在所有 python3 提交中击败了5.05%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            num_dict[value] = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            v = num_dict.get(target-value)</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> v != index:</span><br><span class="line">                <span class="keyword">return</span>[index, v]</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">target = <span class="number">6</span></span><br><span class="line">print(s.twoSum(nums, target))</span><br></pre></td></tr></table></figure>

<h3><span id="2-liang-shu-xiang-jia">2.两数相加</span></h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>        输出：7 -&gt; 0 -&gt; 8<br>        原因：342 + 465 = 807</p>
<p>执行用时 :72 ms, 在所有 python3 提交中击败了98.47%的用户<br>        内存消耗 :13.8 MB, 在所有 python3 提交中击败了5.06%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        base = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = base</span><br><span class="line">        curry = <span class="number">0</span>  <span class="comment"># 两数相加，大于10时的十位，即进位，需在下一位加上该值</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            sum = l1.val + l2.val + curry</span><br><span class="line">            index = sum % <span class="number">10</span></span><br><span class="line">            tmp.next = ListNode(index)</span><br><span class="line">            curry = sum // <span class="number">10</span></span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            sum = l1.val + curry</span><br><span class="line">            index = sum % <span class="number">10</span></span><br><span class="line">            tmp.next = ListNode(index)</span><br><span class="line">            curry = sum // <span class="number">10</span></span><br><span class="line">            l1 = l1.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            sum = l2.val + curry</span><br><span class="line">            index = sum % <span class="number">10</span></span><br><span class="line">            tmp.next = ListNode(index)</span><br><span class="line">            curry = sum // <span class="number">10</span></span><br><span class="line">            l2 = l2.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>):</span><br><span class="line">            tmp.next = ListNode(sum//<span class="number">10</span>)</span><br><span class="line">        base = base.next</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="comment"># l1 = 342</span></span><br><span class="line">l1 = ListNode(<span class="number">2</span>)</span><br><span class="line">l1_next = l1.next = ListNode(<span class="number">4</span>)</span><br><span class="line">l1_next.next = ListNode(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># l2 = 465</span></span><br><span class="line">l2 = ListNode(<span class="number">5</span>)</span><br><span class="line">l2_next = l2.next = ListNode(<span class="number">6</span>)</span><br><span class="line">l2_next.next = ListNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># l1 + l2 = 807</span></span><br><span class="line">ret = s.addTwoNumbers(l1, l2)</span><br><span class="line"><span class="keyword">while</span> ret:</span><br><span class="line">    print(<span class="string">"ret:"</span>, ret.val)</span><br><span class="line">    ret = ret.next</span><br></pre></td></tr></table></figure>

<h3><span id="3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan">3.无重复字符的最长子串</span></h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “abcabcbb”</p>
<p>输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “bbbb”</p>
<p>输出: 1</p>
<p>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “pwwkew”</p>
<p>输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p>
<p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力解法，两层for循环</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            tmp_list = []</span><br><span class="line">            tmp_list.append(s[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> tmp_list:</span><br><span class="line">                    tmp_list.append(s[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> len(tmp_list) &gt; max_len:</span><br><span class="line">                max_len = len(tmp_list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<p><strong>思路优化</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(num) == k:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        stack = [num[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; num[i] <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(num[i])</span><br><span class="line">        <span class="comment"># k &gt; 0说明剩余数字为全部相同或者递增如：11111或12345</span></span><br><span class="line">        <span class="comment"># 将后k个删除即可</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            stack = stack[:-k]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> stack[<span class="number">0</span>] == <span class="string">'0'</span> <span class="keyword">and</span> len(stack) &gt; <span class="number">1</span>:</span><br><span class="line">                stack = stack[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="string">"1234560"</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">ret = Solution().removeKdigits(num, <span class="number">6</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="5-zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua">5. 最长回文子串-动态规划</span></h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p><strong>示例 1</strong>：</p>
<p>输入: “babad”</p>
<p>输出: “bab”</p>
<p>注意: “aba” 也是一个有效答案。</p>
<p><strong>示例 2</strong>：</p>
<p>输入: “cbbd”</p>
<p>输出: “bb”</p>
<p><strong>暴力解法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        result = s[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)):</span><br><span class="line">                is_back_to_text = self.isBackTotext(s, i, j)</span><br><span class="line">                <span class="keyword">if</span> is_back_to_text <span class="keyword">and</span> j - i + <span class="number">1</span> &gt; max_len:</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    result = s[i:j+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBackTotext</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>动态规划</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            str1 = self.getLongestPalindrome(s, i, i)</span><br><span class="line">            <span class="keyword">if</span> len(str1) &gt;len(result):</span><br><span class="line">                result = str1</span><br><span class="line">            str2 = self.getLongestPalindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> len(str2) &gt;len(result):</span><br><span class="line">                result = str2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLongestPalindrome</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s[left+<span class="number">1</span>:right]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"babad"</span></span><br><span class="line">ret = Solution().longestPalindrome(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="7-zheng-shu-fan-zhuan">7. 整数反转</span></h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: 123</p>
<p>输出: 321</p>
<p> <strong>示例 2</strong>:</p>
<p>输入: -123</p>
<p>输出: -321</p>
<p><strong>示例 3</strong>:</p>
<p>输入: 120</p>
<p>输出: 21</p>
<p>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>例如：</p>
<p>在python中 ：-53除以10=-6 …7 所以python中 -53%10=7</p>
<p>在c语言中，-53除以10=-5 … -3 所以c语言中 -53%10=-3</p>
<p>（python3中， /是精确除法，//是向下取整除法，%是求模，四舍五入取整round, 向零取整int, 向下和向上取整函数math.floor, math.ceil）</p>
<p><strong>解法一</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        tmp = x</span><br><span class="line">        <span class="keyword">if</span> tmp &lt; <span class="number">0</span>:</span><br><span class="line">            tmp = -tmp</span><br><span class="line">        str_tmp = str(tmp)</span><br><span class="line">        str_tmp = str_tmp[::<span class="number">-1</span>]</span><br><span class="line">        int_tmp = int(str_tmp)</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            int_tmp = -int_tmp</span><br><span class="line">        <span class="keyword">if</span> int_tmp &lt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> int_tmp &gt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> int_tmp</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            num = -x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = x</span><br><span class="line">        num_list = []</span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            tmp = num % <span class="number">10</span></span><br><span class="line">            num_list.append(tmp)</span><br><span class="line">            num = num // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        num_list.reverse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> num_list:</span><br><span class="line">            tmp = num_list.pop()</span><br><span class="line">            num = num * <span class="number">10</span> + tmp</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            num = -num</span><br><span class="line">        <span class="keyword">if</span> num &lt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> num &gt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().reverse(<span class="number">-123</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="8-zi-fu-chuan-zhuan-huan-zheng-shu-atoi">8. 字符串转换整数 (atoi)</span></h3><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明</strong>：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2<strong>31, 2</strong>31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2<strong>31 − 1) 或 INT_MIN (−2</strong>31) 。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “42”</p>
<p>输出: 42</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “  -42”</p>
<p>输出: -42</p>
<p>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。</p>
<p>   我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “4193 with words”</p>
<p>输出: 4193</p>
<p>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
<p><strong>示例 4</strong>:</p>
<p>输入: “words and 987”</p>
<p>输出: 0</p>
<p>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。</p>
<p>   因此无法执行有效的转换。</p>
<p><strong>示例 5</strong>:</p>
<p>输入: “-91283472332”</p>
<p>输出: -2147483648</p>
<p>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。</p>
<p>   因此返回 INT_MIN (−2**31) 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, strs: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> strs == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        size = len(strs)</span><br><span class="line">        num_list = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        nums = set(str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="keyword">if</span> strs[i] == <span class="string">' '</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> strs[i] == <span class="string">'-'</span> <span class="keyword">or</span> strs[i] == <span class="string">'+'</span> <span class="keyword">or</span> strs[i] <span class="keyword">in</span> nums:</span><br><span class="line">                index = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            num_list.append(strs[index])</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= size <span class="keyword">or</span> strs[index] <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        ret_str = <span class="string">""</span>.join(num_list)</span><br><span class="line">        <span class="keyword">if</span> len(ret_str) == <span class="number">1</span> <span class="keyword">and</span> ret_str[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ret_num = int(ret_str)</span><br><span class="line">        <span class="keyword">if</span> ret_num &lt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> ret_num &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> ret_num &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2147483648</span></span><br><span class="line">        <span class="keyword">return</span> ret_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"2147483648"</span></span><br><span class="line">ret = Solution().myAtoi(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="9-hui-wen-shu">9. 回文数</span></h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: 121</p>
<p>输出: true</p>
<p><strong>示例 2</strong>:</p>
<p>输入: -121</p>
<p>输出: false</p>
<p>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: 10</p>
<p>输出: false</p>
<p>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
<p>进阶:</p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        num = x</span><br><span class="line">        new_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            tmp_num = num % <span class="number">10</span></span><br><span class="line">            new_num = new_num * <span class="number">10</span> + tmp_num</span><br><span class="line">            num = num // <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> new_num == x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">121</span></span><br><span class="line">ret = Solution().isPalindrome(num)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="13-luo-ma-shu-zi-zhuan-zheng-shu">13. 罗马数字转整数</span></h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">500</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">1000</td>
</tr>
</tbody></table>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。</p>
<p>同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</p>
<p>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </p>
<p>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “III”</p>
<p>输出: 3</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “IV”</p>
<p>输出: 4</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “IX”</p>
<p>输出: 9</p>
<p><strong>示例 4</strong>:</p>
<p>输入: “LVIII”</p>
<p>输出: 58</p>
<p>解释: L = 50, V= 5, III = 3.</p>
<p><strong>示例 5</strong>:</p>
<p>输入: “MCMXCIV”</p>
<p>输出: 1994</p>
<p>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        num_dict = dict(I=<span class="number">1</span>, V=<span class="number">5</span>, X=<span class="number">10</span>, L=<span class="number">50</span>, C=<span class="number">100</span>, D=<span class="number">500</span>, M=<span class="number">1000</span>, IV=<span class="number">4</span>, IX=<span class="number">9</span>, XL=<span class="number">40</span>, XC=<span class="number">90</span>, CD=<span class="number">400</span>, CM=<span class="number">900</span>)</span><br><span class="line">        num_list = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> i == (len(s) - <span class="number">1</span>):</span><br><span class="line">                num_list.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'I'</span> <span class="keyword">and</span> (s[i+<span class="number">1</span>] == <span class="string">'V'</span> <span class="keyword">or</span> s[i+<span class="number">1</span>] == <span class="string">'X'</span>):</span><br><span class="line">                tmp = s[i] + s[i+<span class="number">1</span>]</span><br><span class="line">                num_list.append(tmp)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'X'</span> <span class="keyword">and</span> (s[i+<span class="number">1</span>] == <span class="string">'L'</span> <span class="keyword">or</span> s[i+<span class="number">1</span>] == <span class="string">'C'</span>):</span><br><span class="line">                tmp = s[i] + s[i+<span class="number">1</span>]</span><br><span class="line">                num_list.append(tmp)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'C'</span> <span class="keyword">and</span> (s[i+<span class="number">1</span>] == <span class="string">'D'</span> <span class="keyword">or</span> s[i+<span class="number">1</span>] == <span class="string">'M'</span>):</span><br><span class="line">                tmp = s[i] + s[i+<span class="number">1</span>]</span><br><span class="line">                num_list.append(tmp)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num_list.append(s[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">            num = num + num_dict[i]</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

<p><strong>优化-但速度并未明显提升</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        num_dict = dict(I=<span class="number">1</span>, V=<span class="number">5</span>, X=<span class="number">10</span>, L=<span class="number">50</span>, C=<span class="number">100</span>, D=<span class="number">500</span>, M=<span class="number">1000</span>, IV=<span class="number">4</span>, IX=<span class="number">9</span>, XL=<span class="number">40</span>, XC=<span class="number">90</span>, CD=<span class="number">400</span>, CM=<span class="number">900</span>)</span><br><span class="line">        num_set = set((<span class="string">'I'</span>, <span class="string">'V'</span>, <span class="string">'X'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'M'</span>, <span class="string">'IV'</span>, <span class="string">'IX'</span>, <span class="string">'XL'</span>, <span class="string">'XC'</span>, <span class="string">'CD'</span>, <span class="string">'CM'</span>))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> index+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[index]+s[index+<span class="number">1</span>] <span class="keyword">in</span> num_set:</span><br><span class="line">                num = num + num_dict[s[index] + s[index+<span class="number">1</span>]]</span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = num + num_dict[s[index]]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"MCMXCIV"</span></span><br><span class="line">ret = Solution().romanToInt(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="14-zui-chang-gong-gong-qian-zhui">14. 最长公共前缀</span></h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [“flower”,”flow”,”flight”]</p>
<p>输出: “fl”</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [“dog”,”racecar”,”car”]</p>
<p>输出: “”</p>
<p>解释: 输入不存在公共前缀。</p>
<p><strong>说明</strong>:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: [str])</span> -&gt; str:</span></span><br><span class="line">        size = len(strs)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先找出前两个的公共前缀</span></span><br><span class="line">        <span class="comment"># 若存在，则用该前缀与后续str比较</span></span><br><span class="line">        <span class="comment"># 若不存在，则直接返回""</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> strs[<span class="number">0</span>] == <span class="string">""</span> <span class="keyword">or</span> strs[<span class="number">1</span>] == <span class="string">""</span> <span class="keyword">or</span> strs[<span class="number">0</span>][<span class="number">0</span>] != strs[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(strs[<span class="number">0</span>]) <span class="keyword">and</span> index &lt; len(strs[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> strs[<span class="number">0</span>][index] == strs[<span class="number">1</span>][index]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        public_str = strs[<span class="number">0</span>][:index]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, size):</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 判断首位是否相同，不同直接返回""</span></span><br><span class="line">            <span class="keyword">if</span> strs[i] == <span class="string">""</span> <span class="keyword">or</span> public_str[index] != strs[i][index]:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; len(public_str) <span class="keyword">and</span> index &lt; len(strs[i]):</span><br><span class="line">                <span class="keyword">if</span> public_str[index] == strs[i][index]:</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            public_str = public_str[<span class="number">0</span>:index]</span><br><span class="line">        <span class="keyword">return</span> public_str</span><br></pre></td></tr></table></figure>

<p><strong>大神解法</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: [str])</span> -&gt; str:</span></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> zip(*strs):</span><br><span class="line">            <span class="keyword">if</span> len(set(i)) == <span class="number">1</span>:</span><br><span class="line">                s += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">strs = [<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>]</span><br><span class="line">ret = Solution().longestCommonPrefix(strs)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="20-you-xiao-de-gua-hao-zhan">20.有效的括号-栈</span></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。</p>
<p>左括号必须以正确的顺序闭合。</p>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “()”</p>
<p>输出: true</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “()[]{}”</p>
<p>输出: true</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “(]”</p>
<p>输出: false</p>
<p><strong>示例 4</strong>:</p>
<p>输入: “([)]”</p>
<p>输出: false</p>
<p><strong>示例 5</strong>:</p>
<p>输入: “{[]}”</p>
<p>输出: true</p>
<p>执行用时 :40 ms, 在所有 python3 提交中击败了91.98%的用户</p>
<p>内存消耗 :13.7 MB, 在所有 python3 提交中击败了5.51%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span>(len(stack) &lt;= <span class="number">0</span>):</span><br><span class="line">                stack.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            last = stack.pop()</span><br><span class="line">            <span class="comment"># 配对成功</span></span><br><span class="line">            <span class="keyword">if</span> (last == <span class="string">'('</span> <span class="keyword">and</span> i == <span class="string">')'</span> <span class="keyword">or</span></span><br><span class="line">                last == <span class="string">'['</span> <span class="keyword">and</span> i == <span class="string">']'</span> <span class="keyword">or</span></span><br><span class="line">                last == <span class="string">'&#123;'</span> <span class="keyword">and</span> i == <span class="string">'&#125;'</span>):</span><br><span class="line">                    print(last, <span class="string">" and "</span>, i, <span class="string">"success!"</span>)</span><br><span class="line">            <span class="comment"># 配对上一个符号和当前符号一次入栈</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(last)</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len(stack) &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">str_test = <span class="string">"([)]"</span></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.isValid(str_test))</span><br></pre></td></tr></table></figure>

<h3><span id="21-he-bing-liang-ge-you-xu-lian-biao">21. 合并两个有序链表</span></h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例</strong>：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p>
<p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            cur.next = l1</span><br><span class="line">        <span class="keyword">elif</span> l2:</span><br><span class="line">            cur.next = l2</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">l1.next = ListNode(<span class="number">2</span>)</span><br><span class="line">l1_next = l1.next</span><br><span class="line">l1_next.next = ListNode(<span class="number">4</span>)</span><br><span class="line">l2 = ListNode(<span class="number">1</span>)</span><br><span class="line">l2.next = ListNode(<span class="number">3</span>)</span><br><span class="line">l2_next = l2.next</span><br><span class="line">l2_next.next = ListNode(<span class="number">4</span>)</span><br><span class="line">ret = Solution().mergeTwoLists(l1, l2)</span><br><span class="line"><span class="keyword">while</span> ret:</span><br><span class="line">    print(ret.val)</span><br><span class="line">    ret = ret.next</span><br></pre></td></tr></table></figure>

<h3><span id="53-zui-da-zi-xu-he-dong-tai-gui-hua">53. 最大子序和-动态规划</span></h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例</strong>:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p>
<p>输出: 6</p>
<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> max(nums) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        local_max = <span class="number">0</span></span><br><span class="line">        global_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            local_max = max(<span class="number">0</span>, local_max+num)</span><br><span class="line">            global_max = max(local_max, global_max)</span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure>

<h3><span id="55-tiao-yue-you-xi-tan-lan-suan-fa">55.跳跃游戏-贪婪算法</span></h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [2,3,1,1,4]</p>
<p>输出: true</p>
<p>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [3,2,1,0,4]</p>
<p>输出: false</p>
<p>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>思路：从后往前走，看start所在位置+start所在位置可走步数能否大于end所在位置</p>
<p>   若大于，则说明start可以到达end位置，则end位置可往前移</p>
<p>   最终若end到达0点，则说明可能够到达最后一个位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从后往前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: [int])</span> -&gt; bool:</span></span><br><span class="line">        end = len(nums) - <span class="number">1</span></span><br><span class="line">        start = len(nums) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> start &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[start] + start &gt;= end:</span><br><span class="line">                end = start</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> end &lt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">ret = s.canJump(nums)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="62-bu-tong-lu-jing-dong-tai-gui-hua">62. 不同路径-动态规划</span></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: m = 3, n = 2</p>
<p>输出: 3</p>
<p>解释:</p>
<p>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li><p>向右 -&gt; 向右 -&gt; 向下</p>
</li>
<li><p>向右 -&gt; 向下 -&gt; 向右</p>
</li>
<li><p>向下 -&gt; 向右 -&gt; 向右</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*n] + [[<span class="number">1</span>]+[<span class="number">0</span>] * (n<span class="number">-1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().uniquePaths(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="63-bu-tong-lu-jing-ii">63.不同路径II</span></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p><strong>示例 1</strong>:</p>
<p>输入:</p>
<p>[ [0,0,0],</p>
<p> [0,1,0],</p>
<p> [0,0,0]]</p>
<p>输出: 2</p>
<p>解释:</p>
<p>3x3 网格的正中间有一个障碍物。</p>
<p>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li><p>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</p>
</li>
<li><p>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p>
</li>
</ol>
<p><strong>思路</strong>: 将障碍位置可以到达的方法设为0即可(该方法速度过慢)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># m 行 ,n 列</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j] + obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>优化思路</strong>:将0,0位置的赋值，以及第一行和第一列的赋值提出来,避免双层循环内大量if判断降低运行速度.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># m 行 ,n 列</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将第一行数据赋值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][j] = <span class="number">1</span> <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][j<span class="number">-1</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将第一列数据赋值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[i<span class="number">-1</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j] + obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">ret = Solution().uniquePathsWithObstacles(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="64-zui-xiao-lu-jing-he">64. 最小路径和</span></h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p><strong>示例</strong>:</p>
<p>输入:</p>
<p>[ [1,3,1],</p>
<p> [1,5,1],</p>
<p> [4,2,1]]</p>
<p>输出: 7</p>
<p>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        m = len(grid)     <span class="comment"># 行</span></span><br><span class="line">        n = len(grid[<span class="number">0</span>])  <span class="comment"># 列</span></span><br><span class="line">        <span class="comment"># 先把第一列算出来</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            grid[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + grid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再把第一行算出来</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            grid[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + grid[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 比较该位置上方或左方数字，将较小值加给该位置</span></span><br><span class="line">                <span class="comment"># if grid[i-1][j] &lt; grid[i][j-1]:</span></span><br><span class="line">                <span class="comment">#     num = grid[i-1][j]</span></span><br><span class="line">                <span class="comment"># else:</span></span><br><span class="line">                <span class="comment">#     num = grid[i][j-1]</span></span><br><span class="line">                num = grid[i<span class="number">-1</span>][j] <span class="keyword">if</span> grid[i<span class="number">-1</span>][j] &lt; grid[i][j<span class="number">-1</span>] <span class="keyword">else</span> grid[i][j<span class="number">-1</span>]</span><br><span class="line">                grid[i][j] += num</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">     [<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line">     [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line">ret = Solution().minPathSum(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="70-pa-lou-ti">70. 爬楼梯</span></h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>示例 1</strong>：</p>
<p>输入： 2</p>
<p>输出： 2</p>
<p>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li><p>1 阶 + 1 阶</p>
</li>
<li><p>2 阶</p>
</li>
</ol>
<p><strong>示例 2</strong>：</p>
<p>输入： 3</p>
<p>输出： 3</p>
<p>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li><p>1 阶 + 1 阶 + 1 阶</p>
</li>
<li><p>1 阶 + 2 阶</p>
</li>
<li><p>2 阶 + 1 阶</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        climbNums = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        climbNums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        climbNums[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(climbNums)):</span><br><span class="line">            climbNums[i] = climbNums[i<span class="number">-2</span>] + climbNums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> climbNums[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().climbStairs(<span class="number">6</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="71-jian-hua-lu-jing-zhan">71.简化路径-栈</span></h3><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p><strong>示例 1</strong>：</p>
<p>输入：”/home/“</p>
<p>输出：”/home”</p>
<p>解释：注意，最后一个目录名后面没有斜杠。</p>
<p><strong>示例 2</strong>：</p>
<p>输入：”/../“</p>
<p>输出：”/“</p>
<p>解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p>
<p><strong>示例 3</strong>：</p>
<p>输入：”/home//foo/“</p>
<p>输出：”/home/foo”</p>
<p>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</p>
<p><strong>示例 4</strong>：</p>
<p>输入：”/a/./b/../../c/“</p>
<p>输出：”/c”</p>
<p><strong>示例 5</strong>：</p>
<p>输入：”/a/../../b/../c//.//“</p>
<p>输出：”/c”</p>
<p><strong>示例 6</strong>：</p>
<p>输入：”/a//b////c/d//././/..”</p>
<p>输出：”/a/b/c”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        path_list = path.split(<span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path_list:</span><br><span class="line">            <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> i == <span class="string">".."</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> i != <span class="string">'.'</span> <span class="keyword">and</span> i != <span class="string">''</span> <span class="keyword">and</span> i != <span class="string">'..'</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.simplifyPath(<span class="string">"/../"</span>))</span><br></pre></td></tr></table></figure>

<h3><span id="94-er-cha-shu-de-zhong-xu-bian-li">94.二叉树的中序遍历</span></h3><p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出: [1,3,2]</p>
<p>执行用时 :44 ms, 在所有 python3 提交中击败了75.75%的用户</p>
<p>内存消耗 :13.7 MB, 在所有 python3 提交中击败了5.32%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ret, stack = [], []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.val <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                ret.append(node.val)</span><br><span class="line">            root = node.right</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = TreeNode(<span class="number">1</span>)</span><br><span class="line">t.left = <span class="literal">None</span></span><br><span class="line">t.right = TreeNode(<span class="number">2</span>)</span><br><span class="line">t2 = t.right</span><br><span class="line">t2.left = TreeNode(<span class="number">3</span>)</span><br><span class="line">t2.right = TreeNode(<span class="literal">None</span>)</span><br><span class="line">t3 = t2.left</span><br><span class="line">t3.left = <span class="literal">None</span></span><br><span class="line">t3.right = <span class="literal">None</span></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.inorderTraversal(t)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="122-mai-mai-gu-piao-de-zui-jia-shi-ji-ii-tan-lan-suan-fa">122.买卖股票的最佳时机 II-贪婪算法</span></h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [7,1,5,3,6,4]</p>
<p>输出: 7</p>
<p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p>
<p>   随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [1,2,3,4,5]</p>
<p>输出: 4</p>
<p>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p>
<p>   注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</p>
<p>   因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: [7,6,4,3,1]</p>
<p>输出: 0</p>
<p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>思路：所有上涨交易日都买卖，所有下降交易日都不买卖</p>
<p>   “等价于每天都买卖”，把可能跨越多天的买卖都化解成相邻两天的买卖</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: [int])</span> -&gt; int:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            tmp = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">                sum += tmp</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">price = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ret = s.maxProfit(price)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="134-jia-you-zhan-tan-lan-suan-fa">134.加油站-贪婪算法</span></h3><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明: </p>
<p>如果题目有解，该答案即为唯一答案。</p>
<p>输入数组均为非空数组，且长度相同。</p>
<p>输入数组中的元素均为非负数。</p>
<p><strong>示例 1</strong>:</p>
<p>输入:</p>
<p>gas = [1,2,3,4,5]</p>
<p>cost = [3,4,5,1,2]</p>
<p>输出: 3</p>
<p>解释:</p>
<p>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</p>
<p>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</p>
<p>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</p>
<p>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</p>
<p>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</p>
<p>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</p>
<p>因此，3 可为起始索引。</p>
<p><strong>示例 2</strong>:</p>
<p>输入:</p>
<p>gas = [2,3,4]</p>
<p>cost = [3,4,3]</p>
<p>输出: -1</p>
<p>解释:</p>
<p>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</p>
<p>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</p>
<p>开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</p>
<p>开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</p>
<p>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</p>
<p>因此，无论怎样，你都不可能绕环路行驶一周。</p>
<p>这道题还有些不清楚</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        location = <span class="number">0</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果每个站点加的油总量和小于消耗的总油量，则肯定环绕不了一周</span></span><br><span class="line">        <span class="keyword">if</span> sum(gas) &lt; sum(cost):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            total_sum += gas[index] - cost[index]</span><br><span class="line">            <span class="keyword">if</span> total_sum &lt; <span class="number">0</span>:</span><br><span class="line">                location = index+<span class="number">1</span></span><br><span class="line">                total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().canCompleteCircuit([<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>], [<span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-dui">215.数组中的第K个最大元素-堆</span></h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [3,2,1,5,6,4] 和 k = 2</p>
<p>输出: 5</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</p>
<p>输出: 4</p>
<p>说明:</p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: [int], k: int)</span> -&gt; int:</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[:k]:</span><br><span class="line">            heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">                heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.findKthLargest(nums, <span class="number">2</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="264-chou-shu-ii-dui">264.丑数II-堆</span></h3><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p><strong>示例</strong>:</p>
<p>输入: n = 10</p>
<p>输出: 12</p>
<p>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
<p><strong>说明</strong>: </p>
<p>1 是丑数。</p>
<p>n 不超过1690。</p>
<p>因为丑数是2, 3, 5的倍数，我们不断把它们的倍数压入栈中，再按顺序弹出！</p>
<p>时间复杂度：nlogn</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heap = []</span><br><span class="line">        heapq.heappush(heap, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> ret == heap[<span class="number">0</span>]:</span><br><span class="line">                ret = heapq.heappop(heap)</span><br><span class="line">            a, b, c = ret*<span class="number">2</span>, ret*<span class="number">3</span>, ret*<span class="number">5</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c]:</span><br><span class="line">                heapq.heappush(heap, i)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.nthUglyNumber(<span class="number">9</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="313-chao-ji-chou-shu-dui">313.超级丑数-堆</span></h3><p>编写一段程序来查找第 n 个超级丑数。</p>
<p>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</p>
<p><strong>示例:</strong></p>
<p>输入: n = 12, primes = [2,7,13,19]</p>
<p>输出: 32</p>
<p>解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</p>
<p><strong>说明</strong>:</p>
<p>1 是任何给定 primes 的超级丑数。</p>
<p> 给定 primes 中的数字以升序排列。</p>
<p>0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。</p>
<p>第 n 个超级丑数确保在 32 位有符整数范围内。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span><span class="params">(self, n: int, primes: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heap = []</span><br><span class="line">        heapq.heappush(heap, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> ret == heap[<span class="number">0</span>]:</span><br><span class="line">                ret = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> primes:</span><br><span class="line">                heapq.heappush(heap, ret*i)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">primes = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">19</span>]</span><br><span class="line">ret = s.nthSuperUglyNumber(<span class="number">12</span>, primes)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="347-qian-k-ge-gao-pin-yuan-su-dui">347.前 K 个高频元素-堆</span></h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2</p>
<p>输出: [1,2]</p>
<p><strong>示例 2</strong>:</p>
<p>输入: nums = [1], k = 1</p>
<p>输出: [1]</p>
<p><strong>说明</strong>：</p>
<p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</p>
<p>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        num_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> num_dict:</span><br><span class="line">                num_dict[i] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            num_dict[i] += <span class="number">1</span></span><br><span class="line">        ret = sorted(num_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        ret = ret[:k]</span><br><span class="line">        ret = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> ret]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">        </span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ret = s.topKFrequent(nums, <span class="number">2</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = collections.Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ret = s.topKFrequent(nums, <span class="number">2</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="376-bai-dong-xu-lie-tan-lan-suan-fa">376.摆动序列-贪婪算法</span></h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如, [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。</p>
<p>相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [1,7,4,9,2,5]</p>
<p>输出: 6</p>
<p>解释: 整个序列均为摆动序列。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [1,17,5,10,13,15,10,5,16,8]</p>
<p>输出: 7</p>
<p>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: [1,2,3,4,5,6,7,8,9]</p>
<p>输出: 2</p>
<p>进阶:</p>
<p>你能否用 O(n) 时间复杂度完成此题?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        max_len_list = [nums[<span class="number">0</span>]]</span><br><span class="line">        UP = <span class="literal">False</span></span><br><span class="line">        DOWN = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> UP <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                UP = <span class="literal">True</span></span><br><span class="line">                DOWN = <span class="literal">False</span></span><br><span class="line">                max_len_list.append(nums[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> UP <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 持续上升，替换为最大值</span></span><br><span class="line">                max_len_list[<span class="number">-1</span>] = nums[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> DOWN <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                DOWN = <span class="literal">True</span></span><br><span class="line">                UP = <span class="literal">False</span></span><br><span class="line">                max_len_list.append(nums[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> DOWN <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                max_len_list[<span class="number">-1</span>] = nums[i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> len(max_len_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">ret = Solution().wiggleMaxLength(nums)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="392-pan-duan-zi-xu-lie-tan-lan-suan-fa">392.判断子序列-贪婪算法</span></h3><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p><strong>示例 1</strong>:</p>
<p>s = “abc”, t = “ahbgdc”</p>
<p>返回 true.</p>
<p><strong>示例 2</strong>:</p>
<p>s = “axc”, t = “ahbgdc”</p>
<p>返回 false.</p>
<p>后续挑战 :</p>
<p>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] == i:</span><br><span class="line">                s = s[<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> len(s) &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.isSubsequence(<span class="string">""</span>, <span class="string">"ahbgdc"</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="402-yi-diao-k-wei-shu-zi-tan-lan-suan-fa">402.移掉K位数字-贪婪算法</span></h3><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<p>num 的长度小于 10002 且 ≥ k。</p>
<p>num 不会包含任何前导零。</p>
<p><strong>示例 1</strong> :</p>
<p>输入: num = “1432219”, k = 3</p>
<p>输出: “1219”</p>
<p>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p>
<p><strong>示例 2</strong> :</p>
<p>输入: num = “10200”, k = 1</p>
<p>输出: “200”</p>
<p>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<p><strong>示例 3</strong> :</p>
<p>输入: num = “10”, k = 2</p>
<p>输出: “0”</p>
<p>解释: 从原数字移除所有的数字，剩余为空就是0。</p>
<p>利用桟维持一个递增的序列，也就是说将字符串中字符依次入栈，</p>
<p>如果当前字符比栈顶元素小，并且还可以继续删除元素，那么就将栈顶元素移掉，且继续向下一个栈顶元素比较，尽量维持序列递增，也可以算是一个贪心思想。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(num) == k:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        stack = [num[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; num[i] <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(num[i])</span><br><span class="line">        <span class="comment"># k &gt; 0说明剩余数字为全部相同或者递增如：11111或12345</span></span><br><span class="line">        <span class="comment"># 将后k个删除即可</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            stack = stack[:-k]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> stack[<span class="number">0</span>] == <span class="string">'0'</span> <span class="keyword">and</span> len(stack) &gt; <span class="number">1</span>:</span><br><span class="line">                stack = stack[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="string">"1234560"</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">ret = Solution().removeKdigits(num, <span class="number">6</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="455-fen-fa-bing-gan-tan-lan-suan-fa">455.分发饼干-贪婪算法</span></h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，</p>
<p>这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，</p>
<p>这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>注意：</p>
<p>你可以假设胃口值为正。</p>
<p>一个小朋友最多只能拥有一块饼干。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [1,2,3], [1,1]</p>
<p>输出: 1</p>
<p>解释:</p>
<p>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</p>
<p>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</p>
<p>所以你应该输出1。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [1,2], [1,2,3]</p>
<p>输出: 2</p>
<p>解释:</p>
<p>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</p>
<p>你拥有的饼干数量和尺寸都足以让所有孩子满足。</p>
<p>所以你应该输出2.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span><span class="params">(self, g: [int], s: [int])</span> -&gt; int:</span></span><br><span class="line">        child_list = sorted(g)  <span class="comment"># 小朋友</span></span><br><span class="line">        cookie_list = sorted(s)  <span class="comment"># 小饼干</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        child_index = <span class="number">0</span></span><br><span class="line">        cookie_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> child_index &lt; len(child_list) <span class="keyword">and</span> cookie_index &lt; len(cookie_list):</span><br><span class="line">            <span class="keyword">if</span> cookie_list[cookie_index] &gt;= child_list[child_index]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">                child_index += <span class="number">1</span></span><br><span class="line">            cookie_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.findContentChildren([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3><span id="703-shu-ju-liu-zhong-de-di-k-da-yuan-su-dui">703.数据流中的第K大元素-堆</span></h3><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p>
<p>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>];</span><br><span class="line">KthLargest kthLargest = <span class="keyword">new</span> KthLargest(<span class="number">3</span>, arr);</span><br><span class="line">kthLargest.add(<span class="number">3</span>);  <span class="comment">// returns 4</span></span><br><span class="line">kthLargest.add(<span class="number">5</span>);  <span class="comment">// returns 5</span></span><br><span class="line">kthLargest.add(<span class="number">10</span>); <span class="comment">// returns 5</span></span><br><span class="line">kthLargest.add(<span class="number">9</span>);  <span class="comment">// returns 8</span></span><br><span class="line">kthLargest.add(<span class="number">4</span>);  <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure>

<p>执行用时 :120 ms, 在所有 python3 提交中击败了95.49%的用户</p>
<p>内存消耗 :17.4 MB, 在所有 python3 提交中击败了5.63%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int, nums: [int])</span>:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums = nums[:k]</span><br><span class="line">        heapq.heapify(self.nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> i &gt; self.nums[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(self.nums)</span><br><span class="line">                heapq.heappush(self.nums, i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="keyword">if</span> len(self.nums) &lt; self.k:</span><br><span class="line">            heapq.heappush(self.nums, val)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.nums[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappop(self.nums)</span><br><span class="line">            heapq.heappush(self.nums, val)</span><br><span class="line">        <span class="keyword">return</span> self.nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">s = KthLargest(k, arr)</span><br><span class="line">ret = s.add(<span class="number">3</span>)</span><br><span class="line">print(ret)  <span class="comment"># 4</span></span><br><span class="line">ret = s.add(<span class="number">5</span>)</span><br><span class="line">print(ret)  <span class="comment"># 5</span></span><br><span class="line">ret = s.add(<span class="number">10</span>)</span><br><span class="line">print(ret)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<h3><span id="1021-shan-chu-zui-wai-ceng-de-gua-hao-zhan">1021.删除最外层的括号-栈</span></h3><p>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
<p><strong>示例 1</strong>：</p>
<p>输入：”(()())(())”</p>
<p>输出：”()()()”</p>
<p>解释：</p>
<p>输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，</p>
<p>删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。</p>
<p><strong>示例 2</strong>：</p>
<p>输入：”(()())(())(()(()))”</p>
<p>输出：”()()()()(())”</p>
<p>解释：</p>
<p>输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，</p>
<p>删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。</p>
<p><strong>示例 3</strong>：</p>
<p>输入：”()()”</p>
<p>输出：””</p>
<p>解释：</p>
<p>输入字符串为 “()()”，原语化分解得到 “()” + “()”，</p>
<p>删除每个部分中的最外层括号后得到 “” + “” = “”。</p>
<p><strong>提示</strong>：</p>
<p>S.length &lt;= 10000</p>
<p>S[i] 为 “(“ 或 “)”</p>
<p>S 是一个有效括号字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeOuterParentheses</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        ret_str = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">if</span>(len(stack) &gt;= <span class="number">1</span>):</span><br><span class="line">                    ret_str += i</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># i == ')'</span></span><br><span class="line">                <span class="keyword">if</span>(len(stack) &gt; <span class="number">1</span>):</span><br><span class="line">                    ret_str += i</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> ret_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">s_test = <span class="string">"(()())(())(()(()))"</span></span><br><span class="line">print(s.removeOuterParentheses(s_test))</span><br></pre></td></tr></table></figure>

<h3><span id="1047-shan-chu-zi-fu-chuan-zhong-de-suo-you-xiang-lin-chong-fu-xiang-zhan">1047.删除字符串中的所有相邻重复项-栈</span></h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例</strong>：</p>
<p>输入：”abbaca”</p>
<p>输出：”ca”</p>
<p>解释：</p>
<p>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p>
<p><strong>提示</strong>：</p>
<p>1 &lt;= S.length &lt;= 20000</p>
<p>S 仅由小写英文字母组成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == i:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        ret_str = <span class="string">''</span>.join(stack)</span><br><span class="line">        <span class="keyword">return</span> ret_str</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.removeDuplicates(<span class="string">"abbaca"</span>))</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://139.180.173.25/2019/11/06/LeetCode/" data-id="ck2on96cq0000agxu4d5f0sd4" class="article-share-link" data-share="baidu" data-title="LeetCode">Share</a>
      

      
        <a href="http://139.180.173.25/2019/11/06/LeetCode/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/10/22/hexo/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">hexo</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2019/11/06/LeetCode/" data-title="LeetCode" data-url="http://139.180.173.25/2019/11/06/LeetCode/"></div>
  </section>

</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">python学习笔记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/LeetCode/" style="font-size: 10px;">LeetCode</a> <a href="/tags/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">python学习笔记</a> <a href="/tags/%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">实践</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/06/LeetCode/">LeetCode</a>
          </li>
        
          <li>
            <a href="/2019/10/22/hexo/">hexo</a>
          </li>
        
          <li>
            <a href="/2019/10/20/python/">python学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/scooola" target="_blank">scola</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 scola<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
