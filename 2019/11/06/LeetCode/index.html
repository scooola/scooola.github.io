<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">
  <meta name="google-site-verification" content="lh1OQ7TnAGvDqYmoqelnZDREooOZbmdviIQmlVS19xE">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="LeetCode最近在学习python3，便想到了用python3刷LeetCode，既可以学习到python3的一些语法细节，也可以锻炼算法能力。 刷题未完全按照LeetCode排列顺序去刷，但是排布会按照题号大小去排列。算法小白，大佬看到勿喷。">
<meta name="keywords" content="LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode">
<meta property="og:url" content="https:&#x2F;&#x2F;scooola.github.io&#x2F;2019&#x2F;11&#x2F;06&#x2F;LeetCode&#x2F;index.html">
<meta property="og:site_name" content="scola的博客">
<meta property="og:description" content="LeetCode最近在学习python3，便想到了用python3刷LeetCode，既可以学习到python3的一些语法细节，也可以锻炼算法能力。 刷题未完全按照LeetCode排列顺序去刷，但是排布会按照题号大小去排列。算法小白，大佬看到勿喷。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-11-08T06:56:23.919Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://scooola.github.io/2019/11/06/LeetCode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>LeetCode | scola的博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">scola的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://scooola.github.io/2019/11/06/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/xiamu.jpg">
      <meta itemprop="name" content="scola">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scola的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-06 09:50:19" itemprop="dateCreated datePublished" datetime="2019-11-06T09:50:19+08:00">2019-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-08 14:56:23" itemprop="dateModified" datetime="2019-11-08T14:56:23+08:00">2019-11-08</time>
              </span>

          
            <span id="/2019/11/06/LeetCode/" class="post-meta-item leancloud_visitors" data-flag-title="LeetCode" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/11/06/LeetCode/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/11/06/LeetCode/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p>最近在学习python3，便想到了用python3刷LeetCode，既可以学习到python3的一些语法细节，也可以锻炼算法能力。</p>
<p>刷题未完全按照LeetCode排列顺序去刷，但是排布会按照题号大小去排列。算法小白，大佬看到勿喷。</p>
<a id="more"></a>

<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]</p>
<p>执行用时 :64 ms, 在所有 python3 提交中击败了93.62%的用户<br>        内存消耗 :15.5 MB, 在所有 python3 提交中击败了5.05%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            num_dict[value] = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            v = num_dict.get(target-value)</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> v != index:</span><br><span class="line">                <span class="keyword">return</span>[index, v]</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">target = <span class="number">6</span></span><br><span class="line">print(s.twoSum(nums, target))</span><br></pre></td></tr></table></figure>

<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>        输出：7 -&gt; 0 -&gt; 8<br>        原因：342 + 465 = 807</p>
<p>执行用时 :72 ms, 在所有 python3 提交中击败了98.47%的用户<br>        内存消耗 :13.8 MB, 在所有 python3 提交中击败了5.06%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        base = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = base</span><br><span class="line">        curry = <span class="number">0</span>  <span class="comment"># 两数相加，大于10时的十位，即进位，需在下一位加上该值</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            sum = l1.val + l2.val + curry</span><br><span class="line">            index = sum % <span class="number">10</span></span><br><span class="line">            tmp.next = ListNode(index)</span><br><span class="line">            curry = sum // <span class="number">10</span></span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            sum = l1.val + curry</span><br><span class="line">            index = sum % <span class="number">10</span></span><br><span class="line">            tmp.next = ListNode(index)</span><br><span class="line">            curry = sum // <span class="number">10</span></span><br><span class="line">            l1 = l1.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            sum = l2.val + curry</span><br><span class="line">            index = sum % <span class="number">10</span></span><br><span class="line">            tmp.next = ListNode(index)</span><br><span class="line">            curry = sum // <span class="number">10</span></span><br><span class="line">            l2 = l2.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>):</span><br><span class="line">            tmp.next = ListNode(sum//<span class="number">10</span>)</span><br><span class="line">        base = base.next</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="comment"># l1 = 342</span></span><br><span class="line">l1 = ListNode(<span class="number">2</span>)</span><br><span class="line">l1_next = l1.next = ListNode(<span class="number">4</span>)</span><br><span class="line">l1_next.next = ListNode(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># l2 = 465</span></span><br><span class="line">l2 = ListNode(<span class="number">5</span>)</span><br><span class="line">l2_next = l2.next = ListNode(<span class="number">6</span>)</span><br><span class="line">l2_next.next = ListNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># l1 + l2 = 807</span></span><br><span class="line">ret = s.addTwoNumbers(l1, l2)</span><br><span class="line"><span class="keyword">while</span> ret:</span><br><span class="line">    print(<span class="string">"ret:"</span>, ret.val)</span><br><span class="line">    ret = ret.next</span><br></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “abcabcbb”</p>
<p>输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “bbbb”</p>
<p>输出: 1</p>
<p>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “pwwkew”</p>
<p>输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p>
<p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力解法，两层for循环</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            tmp_list = []</span><br><span class="line">            tmp_list.append(s[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> tmp_list:</span><br><span class="line">                    tmp_list.append(s[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> len(tmp_list) &gt; max_len:</span><br><span class="line">                max_len = len(tmp_list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<p><strong>思路优化</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(num) == k:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        stack = [num[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; num[i] <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(num[i])</span><br><span class="line">        <span class="comment"># k &gt; 0说明剩余数字为全部相同或者递增如：11111或12345</span></span><br><span class="line">        <span class="comment"># 将后k个删除即可</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            stack = stack[:-k]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> stack[<span class="number">0</span>] == <span class="string">'0'</span> <span class="keyword">and</span> len(stack) &gt; <span class="number">1</span>:</span><br><span class="line">                stack = stack[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="string">"1234560"</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">ret = Solution().removeKdigits(num, <span class="number">6</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="5-最长回文子串-动态规划"><a href="#5-最长回文子串-动态规划" class="headerlink" title="5. 最长回文子串-动态规划"></a>5. 最长回文子串-动态规划</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p><strong>示例 1</strong>：</p>
<p>输入: “babad”</p>
<p>输出: “bab”</p>
<p>注意: “aba” 也是一个有效答案。</p>
<p><strong>示例 2</strong>：</p>
<p>输入: “cbbd”</p>
<p>输出: “bb”</p>
<p><strong>暴力解法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        result = s[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)):</span><br><span class="line">                is_back_to_text = self.isBackTotext(s, i, j)</span><br><span class="line">                <span class="keyword">if</span> is_back_to_text <span class="keyword">and</span> j - i + <span class="number">1</span> &gt; max_len:</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    result = s[i:j+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBackTotext</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>动态规划</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            str1 = self.getLongestPalindrome(s, i, i)</span><br><span class="line">            <span class="keyword">if</span> len(str1) &gt;len(result):</span><br><span class="line">                result = str1</span><br><span class="line">            str2 = self.getLongestPalindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> len(str2) &gt;len(result):</span><br><span class="line">                result = str2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLongestPalindrome</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s[left+<span class="number">1</span>:right]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"babad"</span></span><br><span class="line">ret = Solution().longestPalindrome(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: 123</p>
<p>输出: 321</p>
<p> <strong>示例 2</strong>:</p>
<p>输入: -123</p>
<p>输出: -321</p>
<p><strong>示例 3</strong>:</p>
<p>输入: 120</p>
<p>输出: 21</p>
<p>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>例如：</p>
<p>在python中 ：-53除以10=-6 …7 所以python中 -53%10=7</p>
<p>在c语言中，-53除以10=-5 … -3 所以c语言中 -53%10=-3</p>
<p>（python3中， /是精确除法，//是向下取整除法，%是求模，四舍五入取整round, 向零取整int, 向下和向上取整函数math.floor, math.ceil）</p>
<p><strong>解法一</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        tmp = x</span><br><span class="line">        <span class="keyword">if</span> tmp &lt; <span class="number">0</span>:</span><br><span class="line">            tmp = -tmp</span><br><span class="line">        str_tmp = str(tmp)</span><br><span class="line">        str_tmp = str_tmp[::<span class="number">-1</span>]</span><br><span class="line">        int_tmp = int(str_tmp)</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            int_tmp = -int_tmp</span><br><span class="line">        <span class="keyword">if</span> int_tmp &lt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> int_tmp &gt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> int_tmp</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            num = -x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = x</span><br><span class="line">        num_list = []</span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            tmp = num % <span class="number">10</span></span><br><span class="line">            num_list.append(tmp)</span><br><span class="line">            num = num // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        num_list.reverse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> num_list:</span><br><span class="line">            tmp = num_list.pop()</span><br><span class="line">            num = num * <span class="number">10</span> + tmp</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            num = -num</span><br><span class="line">        <span class="keyword">if</span> num &lt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> num &gt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().reverse(<span class="number">-123</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h3><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明</strong>：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2<strong>31, 2</strong>31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2<strong>31 − 1) 或 INT_MIN (−2</strong>31) 。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “42”</p>
<p>输出: 42</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “  -42”</p>
<p>输出: -42</p>
<p>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。</p>
<p>   我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “4193 with words”</p>
<p>输出: 4193</p>
<p>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
<p><strong>示例 4</strong>:</p>
<p>输入: “words and 987”</p>
<p>输出: 0</p>
<p>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。</p>
<p>   因此无法执行有效的转换。</p>
<p><strong>示例 5</strong>:</p>
<p>输入: “-91283472332”</p>
<p>输出: -2147483648</p>
<p>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。</p>
<p>   因此返回 INT_MIN (−2**31) 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, strs: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> strs == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        size = len(strs)</span><br><span class="line">        num_list = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        nums = set(str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="keyword">if</span> strs[i] == <span class="string">' '</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> strs[i] == <span class="string">'-'</span> <span class="keyword">or</span> strs[i] == <span class="string">'+'</span> <span class="keyword">or</span> strs[i] <span class="keyword">in</span> nums:</span><br><span class="line">                index = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            num_list.append(strs[index])</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= size <span class="keyword">or</span> strs[index] <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        ret_str = <span class="string">""</span>.join(num_list)</span><br><span class="line">        <span class="keyword">if</span> len(ret_str) == <span class="number">1</span> <span class="keyword">and</span> ret_str[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ret_num = int(ret_str)</span><br><span class="line">        <span class="keyword">if</span> ret_num &lt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> ret_num &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> ret_num &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2147483648</span></span><br><span class="line">        <span class="keyword">return</span> ret_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"2147483648"</span></span><br><span class="line">ret = Solution().myAtoi(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: 121</p>
<p>输出: true</p>
<p><strong>示例 2</strong>:</p>
<p>输入: -121</p>
<p>输出: false</p>
<p>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: 10</p>
<p>输出: false</p>
<p>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
<p>进阶:</p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        num = x</span><br><span class="line">        new_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            tmp_num = num % <span class="number">10</span></span><br><span class="line">            new_num = new_num * <span class="number">10</span> + tmp_num</span><br><span class="line">            num = num // <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> new_num == x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">121</span></span><br><span class="line">ret = Solution().isPalindrome(num)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">500</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">1000</td>
</tr>
</tbody></table>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。</p>
<p>同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</p>
<p>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </p>
<p>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “III”</p>
<p>输出: 3</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “IV”</p>
<p>输出: 4</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “IX”</p>
<p>输出: 9</p>
<p><strong>示例 4</strong>:</p>
<p>输入: “LVIII”</p>
<p>输出: 58</p>
<p>解释: L = 50, V= 5, III = 3.</p>
<p><strong>示例 5</strong>:</p>
<p>输入: “MCMXCIV”</p>
<p>输出: 1994</p>
<p>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        num_dict = dict(I=<span class="number">1</span>, V=<span class="number">5</span>, X=<span class="number">10</span>, L=<span class="number">50</span>, C=<span class="number">100</span>, D=<span class="number">500</span>, M=<span class="number">1000</span>, IV=<span class="number">4</span>, IX=<span class="number">9</span>, XL=<span class="number">40</span>, XC=<span class="number">90</span>, CD=<span class="number">400</span>, CM=<span class="number">900</span>)</span><br><span class="line">        num_list = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> i == (len(s) - <span class="number">1</span>):</span><br><span class="line">                num_list.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'I'</span> <span class="keyword">and</span> (s[i+<span class="number">1</span>] == <span class="string">'V'</span> <span class="keyword">or</span> s[i+<span class="number">1</span>] == <span class="string">'X'</span>):</span><br><span class="line">                tmp = s[i] + s[i+<span class="number">1</span>]</span><br><span class="line">                num_list.append(tmp)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'X'</span> <span class="keyword">and</span> (s[i+<span class="number">1</span>] == <span class="string">'L'</span> <span class="keyword">or</span> s[i+<span class="number">1</span>] == <span class="string">'C'</span>):</span><br><span class="line">                tmp = s[i] + s[i+<span class="number">1</span>]</span><br><span class="line">                num_list.append(tmp)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'C'</span> <span class="keyword">and</span> (s[i+<span class="number">1</span>] == <span class="string">'D'</span> <span class="keyword">or</span> s[i+<span class="number">1</span>] == <span class="string">'M'</span>):</span><br><span class="line">                tmp = s[i] + s[i+<span class="number">1</span>]</span><br><span class="line">                num_list.append(tmp)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num_list.append(s[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">            num = num + num_dict[i]</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

<p><strong>优化-但速度并未明显提升</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        num_dict = dict(I=<span class="number">1</span>, V=<span class="number">5</span>, X=<span class="number">10</span>, L=<span class="number">50</span>, C=<span class="number">100</span>, D=<span class="number">500</span>, M=<span class="number">1000</span>, IV=<span class="number">4</span>, IX=<span class="number">9</span>, XL=<span class="number">40</span>, XC=<span class="number">90</span>, CD=<span class="number">400</span>, CM=<span class="number">900</span>)</span><br><span class="line">        num_set = set((<span class="string">'I'</span>, <span class="string">'V'</span>, <span class="string">'X'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'M'</span>, <span class="string">'IV'</span>, <span class="string">'IX'</span>, <span class="string">'XL'</span>, <span class="string">'XC'</span>, <span class="string">'CD'</span>, <span class="string">'CM'</span>))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> index+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[index]+s[index+<span class="number">1</span>] <span class="keyword">in</span> num_set:</span><br><span class="line">                num = num + num_dict[s[index] + s[index+<span class="number">1</span>]]</span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = num + num_dict[s[index]]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"MCMXCIV"</span></span><br><span class="line">ret = Solution().romanToInt(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [“flower”,”flow”,”flight”]</p>
<p>输出: “fl”</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [“dog”,”racecar”,”car”]</p>
<p>输出: “”</p>
<p>解释: 输入不存在公共前缀。</p>
<p><strong>说明</strong>:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: [str])</span> -&gt; str:</span></span><br><span class="line">        size = len(strs)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先找出前两个的公共前缀</span></span><br><span class="line">        <span class="comment"># 若存在，则用该前缀与后续str比较</span></span><br><span class="line">        <span class="comment"># 若不存在，则直接返回""</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> strs[<span class="number">0</span>] == <span class="string">""</span> <span class="keyword">or</span> strs[<span class="number">1</span>] == <span class="string">""</span> <span class="keyword">or</span> strs[<span class="number">0</span>][<span class="number">0</span>] != strs[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(strs[<span class="number">0</span>]) <span class="keyword">and</span> index &lt; len(strs[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> strs[<span class="number">0</span>][index] == strs[<span class="number">1</span>][index]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        public_str = strs[<span class="number">0</span>][:index]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, size):</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 判断首位是否相同，不同直接返回""</span></span><br><span class="line">            <span class="keyword">if</span> strs[i] == <span class="string">""</span> <span class="keyword">or</span> public_str[index] != strs[i][index]:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; len(public_str) <span class="keyword">and</span> index &lt; len(strs[i]):</span><br><span class="line">                <span class="keyword">if</span> public_str[index] == strs[i][index]:</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            public_str = public_str[<span class="number">0</span>:index]</span><br><span class="line">        <span class="keyword">return</span> public_str</span><br></pre></td></tr></table></figure>

<p><strong>大神解法</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: [str])</span> -&gt; str:</span></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> zip(*strs):</span><br><span class="line">            <span class="keyword">if</span> len(set(i)) == <span class="number">1</span>:</span><br><span class="line">                s += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">strs = [<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>]</span><br><span class="line">ret = Solution().longestCommonPrefix(strs)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="20-有效的括号-栈"><a href="#20-有效的括号-栈" class="headerlink" title="20.有效的括号-栈"></a>20.有效的括号-栈</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。</p>
<p>左括号必须以正确的顺序闭合。</p>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “()”</p>
<p>输出: true</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “()[]{}”</p>
<p>输出: true</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “(]”</p>
<p>输出: false</p>
<p><strong>示例 4</strong>:</p>
<p>输入: “([)]”</p>
<p>输出: false</p>
<p><strong>示例 5</strong>:</p>
<p>输入: “{[]}”</p>
<p>输出: true</p>
<p>执行用时 :40 ms, 在所有 python3 提交中击败了91.98%的用户</p>
<p>内存消耗 :13.7 MB, 在所有 python3 提交中击败了5.51%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span>(len(stack) &lt;= <span class="number">0</span>):</span><br><span class="line">                stack.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            last = stack.pop()</span><br><span class="line">            <span class="comment"># 配对成功</span></span><br><span class="line">            <span class="keyword">if</span> (last == <span class="string">'('</span> <span class="keyword">and</span> i == <span class="string">')'</span> <span class="keyword">or</span></span><br><span class="line">                last == <span class="string">'['</span> <span class="keyword">and</span> i == <span class="string">']'</span> <span class="keyword">or</span></span><br><span class="line">                last == <span class="string">'&#123;'</span> <span class="keyword">and</span> i == <span class="string">'&#125;'</span>):</span><br><span class="line">                    print(last, <span class="string">" and "</span>, i, <span class="string">"success!"</span>)</span><br><span class="line">            <span class="comment"># 配对上一个符号和当前符号一次入栈</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(last)</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len(stack) &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">str_test = <span class="string">"([)]"</span></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.isValid(str_test))</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例</strong>：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p>
<p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            cur.next = l1</span><br><span class="line">        <span class="keyword">elif</span> l2:</span><br><span class="line">            cur.next = l2</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">l1.next = ListNode(<span class="number">2</span>)</span><br><span class="line">l1_next = l1.next</span><br><span class="line">l1_next.next = ListNode(<span class="number">4</span>)</span><br><span class="line">l2 = ListNode(<span class="number">1</span>)</span><br><span class="line">l2.next = ListNode(<span class="number">3</span>)</span><br><span class="line">l2_next = l2.next</span><br><span class="line">l2_next.next = ListNode(<span class="number">4</span>)</span><br><span class="line">ret = Solution().mergeTwoLists(l1, l2)</span><br><span class="line"><span class="keyword">while</span> ret:</span><br><span class="line">    print(ret.val)</span><br><span class="line">    ret = ret.next</span><br></pre></td></tr></table></figure>

<h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1</strong>:</p>
<p>给定数组 nums = [1,1,2],</p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 2</strong>:</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明</strong>:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="keyword">if</span> size &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> size</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        tmp = i</span><br><span class="line">        <span class="keyword">while</span> i &lt; size:</span><br><span class="line">            <span class="comment"># 如果前后两数字相等，则tmp存储当前位置，</span></span><br><span class="line">            <span class="comment"># i向后走一步继续寻找不同数字的位置</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[tmp] = nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                tmp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">ret = Solution().removeDuplicates(nums)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1</strong>:</p>
<p>给定 nums = [3,2,2,3], val = 3,</p>
<p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 2</strong>:</p>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>注意这五个元素可为任意顺序。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明</strong>:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</p>
<p>int len = removeElement(nums, val);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。</p>
<p>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: [int], val: int)</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="comment"># 这道题与上一题思路相似</span></span><br><span class="line">        <span class="comment"># 都是用双指针</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; size:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[cur] = nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ret = Solution().removeElement(s, <span class="number">3</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="53-最大子序和-动态规划"><a href="#53-最大子序和-动态规划" class="headerlink" title="53. 最大子序和-动态规划"></a>53. 最大子序和-动态规划</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例</strong>:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p>
<p>输出: 6</p>
<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> max(nums) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        local_max = <span class="number">0</span></span><br><span class="line">        global_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            local_max = max(<span class="number">0</span>, local_max+num)</span><br><span class="line">            global_max = max(local_max, global_max)</span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure>

<h3 id="55-跳跃游戏-贪婪算法"><a href="#55-跳跃游戏-贪婪算法" class="headerlink" title="55.跳跃游戏-贪婪算法"></a>55.跳跃游戏-贪婪算法</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [2,3,1,1,4]</p>
<p>输出: true</p>
<p>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [3,2,1,0,4]</p>
<p>输出: false</p>
<p>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>思路：从后往前走，看start所在位置+start所在位置可走步数能否大于end所在位置</p>
<p>   若大于，则说明start可以到达end位置，则end位置可往前移</p>
<p>   最终若end到达0点，则说明可能够到达最后一个位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从后往前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: [int])</span> -&gt; bool:</span></span><br><span class="line">        end = len(nums) - <span class="number">1</span></span><br><span class="line">        start = len(nums) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> start &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[start] + start &gt;= end:</span><br><span class="line">                end = start</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> end &lt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">ret = s.canJump(nums)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="62-不同路径-动态规划"><a href="#62-不同路径-动态规划" class="headerlink" title="62. 不同路径-动态规划"></a>62. 不同路径-动态规划</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: m = 3, n = 2</p>
<p>输出: 3</p>
<p>解释:</p>
<p>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li><p>向右 -&gt; 向右 -&gt; 向下</p>
</li>
<li><p>向右 -&gt; 向下 -&gt; 向右</p>
</li>
<li><p>向下 -&gt; 向右 -&gt; 向右</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*n] + [[<span class="number">1</span>]+[<span class="number">0</span>] * (n<span class="number">-1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().uniquePaths(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="63-不同路径II"><a href="#63-不同路径II" class="headerlink" title="63.不同路径II"></a>63.不同路径II</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p><strong>示例 1</strong>:</p>
<p>输入:</p>
<p>[ [0,0,0],</p>
<p> [0,1,0],</p>
<p> [0,0,0]]</p>
<p>输出: 2</p>
<p>解释:</p>
<p>3x3 网格的正中间有一个障碍物。</p>
<p>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li><p>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</p>
</li>
<li><p>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p>
</li>
</ol>
<p><strong>思路</strong>: 将障碍位置可以到达的方法设为0即可(该方法速度过慢)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># m 行 ,n 列</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j] + obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>优化思路</strong>:将0,0位置的赋值，以及第一行和第一列的赋值提出来,避免双层循环内大量if判断降低运行速度.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># m 行 ,n 列</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将第一行数据赋值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][j] = <span class="number">1</span> <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][j<span class="number">-1</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将第一列数据赋值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[i<span class="number">-1</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j] + obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">ret = Solution().uniquePathsWithObstacles(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p><strong>示例</strong>:</p>
<p>输入:</p>
<p>[ [1,3,1],</p>
<p> [1,5,1],</p>
<p> [4,2,1]]</p>
<p>输出: 7</p>
<p>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        m = len(grid)     <span class="comment"># 行</span></span><br><span class="line">        n = len(grid[<span class="number">0</span>])  <span class="comment"># 列</span></span><br><span class="line">        <span class="comment"># 先把第一列算出来</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            grid[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + grid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再把第一行算出来</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            grid[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + grid[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 比较该位置上方或左方数字，将较小值加给该位置</span></span><br><span class="line">                <span class="comment"># if grid[i-1][j] &lt; grid[i][j-1]:</span></span><br><span class="line">                <span class="comment">#     num = grid[i-1][j]</span></span><br><span class="line">                <span class="comment"># else:</span></span><br><span class="line">                <span class="comment">#     num = grid[i][j-1]</span></span><br><span class="line">                num = grid[i<span class="number">-1</span>][j] <span class="keyword">if</span> grid[i<span class="number">-1</span>][j] &lt; grid[i][j<span class="number">-1</span>] <span class="keyword">else</span> grid[i][j<span class="number">-1</span>]</span><br><span class="line">                grid[i][j] += num</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">     [<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line">     [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line">ret = Solution().minPathSum(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>示例 1</strong>：</p>
<p>输入： 2</p>
<p>输出： 2</p>
<p>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li><p>1 阶 + 1 阶</p>
</li>
<li><p>2 阶</p>
</li>
</ol>
<p><strong>示例 2</strong>：</p>
<p>输入： 3</p>
<p>输出： 3</p>
<p>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li><p>1 阶 + 1 阶 + 1 阶</p>
</li>
<li><p>1 阶 + 2 阶</p>
</li>
<li><p>2 阶 + 1 阶</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        climbNums = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        climbNums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        climbNums[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(climbNums)):</span><br><span class="line">            climbNums[i] = climbNums[i<span class="number">-2</span>] + climbNums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> climbNums[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().climbStairs(<span class="number">6</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="71-简化路径-栈"><a href="#71-简化路径-栈" class="headerlink" title="71.简化路径-栈"></a>71.简化路径-栈</h3><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p><strong>示例 1</strong>：</p>
<p>输入：”/home/“</p>
<p>输出：”/home”</p>
<p>解释：注意，最后一个目录名后面没有斜杠。</p>
<p><strong>示例 2</strong>：</p>
<p>输入：”/../“</p>
<p>输出：”/“</p>
<p>解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p>
<p><strong>示例 3</strong>：</p>
<p>输入：”/home//foo/“</p>
<p>输出：”/home/foo”</p>
<p>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</p>
<p><strong>示例 4</strong>：</p>
<p>输入：”/a/./b/../../c/“</p>
<p>输出：”/c”</p>
<p><strong>示例 5</strong>：</p>
<p>输入：”/a/../../b/../c//.//“</p>
<p>输出：”/c”</p>
<p><strong>示例 6</strong>：</p>
<p>输入：”/a//b////c/d//././/..”</p>
<p>输出：”/a/b/c”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        path_list = path.split(<span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path_list:</span><br><span class="line">            <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> i == <span class="string">".."</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> i != <span class="string">'.'</span> <span class="keyword">and</span> i != <span class="string">''</span> <span class="keyword">and</span> i != <span class="string">'..'</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.simplifyPath(<span class="string">"/../"</span>))</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h3><p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出: [1,3,2]</p>
<p>执行用时 :44 ms, 在所有 python3 提交中击败了75.75%的用户</p>
<p>内存消耗 :13.7 MB, 在所有 python3 提交中击败了5.32%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ret, stack = [], []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.val <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                ret.append(node.val)</span><br><span class="line">            root = node.right</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = TreeNode(<span class="number">1</span>)</span><br><span class="line">t.left = <span class="literal">None</span></span><br><span class="line">t.right = TreeNode(<span class="number">2</span>)</span><br><span class="line">t2 = t.right</span><br><span class="line">t2.left = TreeNode(<span class="number">3</span>)</span><br><span class="line">t2.right = TreeNode(<span class="literal">None</span>)</span><br><span class="line">t3 = t2.left</span><br><span class="line">t3.left = <span class="literal">None</span></span><br><span class="line">t3.right = <span class="literal">None</span></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.inorderTraversal(t)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="122-买卖股票的最佳时机-II-贪婪算法"><a href="#122-买卖股票的最佳时机-II-贪婪算法" class="headerlink" title="122.买卖股票的最佳时机 II-贪婪算法"></a>122.买卖股票的最佳时机 II-贪婪算法</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [7,1,5,3,6,4]</p>
<p>输出: 7</p>
<p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p>
<p>   随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [1,2,3,4,5]</p>
<p>输出: 4</p>
<p>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p>
<p>   注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</p>
<p>   因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: [7,6,4,3,1]</p>
<p>输出: 0</p>
<p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>思路：所有上涨交易日都买卖，所有下降交易日都不买卖</p>
<p>   “等价于每天都买卖”，把可能跨越多天的买卖都化解成相邻两天的买卖</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: [int])</span> -&gt; int:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            tmp = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">                sum += tmp</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">price = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ret = s.maxProfit(price)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="134-加油站-贪婪算法"><a href="#134-加油站-贪婪算法" class="headerlink" title="134.加油站-贪婪算法"></a>134.加油站-贪婪算法</h3><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明: </p>
<p>如果题目有解，该答案即为唯一答案。</p>
<p>输入数组均为非空数组，且长度相同。</p>
<p>输入数组中的元素均为非负数。</p>
<p><strong>示例 1</strong>:</p>
<p>输入:</p>
<p>gas = [1,2,3,4,5]</p>
<p>cost = [3,4,5,1,2]</p>
<p>输出: 3</p>
<p>解释:</p>
<p>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</p>
<p>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</p>
<p>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</p>
<p>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</p>
<p>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</p>
<p>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</p>
<p>因此，3 可为起始索引。</p>
<p><strong>示例 2</strong>:</p>
<p>输入:</p>
<p>gas = [2,3,4]</p>
<p>cost = [3,4,3]</p>
<p>输出: -1</p>
<p>解释:</p>
<p>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</p>
<p>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</p>
<p>开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</p>
<p>开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</p>
<p>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</p>
<p>因此，无论怎样，你都不可能绕环路行驶一周。</p>
<p>这道题还有些不清楚</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        location = <span class="number">0</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果每个站点加的油总量和小于消耗的总油量，则肯定环绕不了一周</span></span><br><span class="line">        <span class="keyword">if</span> sum(gas) &lt; sum(cost):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            total_sum += gas[index] - cost[index]</span><br><span class="line">            <span class="keyword">if</span> total_sum &lt; <span class="number">0</span>:</span><br><span class="line">                location = index+<span class="number">1</span></span><br><span class="line">                total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().canCompleteCircuit([<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>], [<span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="215-数组中的第K个最大元素-堆"><a href="#215-数组中的第K个最大元素-堆" class="headerlink" title="215.数组中的第K个最大元素-堆"></a>215.数组中的第K个最大元素-堆</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [3,2,1,5,6,4] 和 k = 2</p>
<p>输出: 5</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</p>
<p>输出: 4</p>
<p>说明:</p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: [int], k: int)</span> -&gt; int:</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[:k]:</span><br><span class="line">            heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">                heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.findKthLargest(nums, <span class="number">2</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="264-丑数II-堆"><a href="#264-丑数II-堆" class="headerlink" title="264.丑数II-堆"></a>264.丑数II-堆</h3><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p><strong>示例</strong>:</p>
<p>输入: n = 10</p>
<p>输出: 12</p>
<p>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
<p><strong>说明</strong>: </p>
<p>1 是丑数。</p>
<p>n 不超过1690。</p>
<p>因为丑数是2, 3, 5的倍数，我们不断把它们的倍数压入栈中，再按顺序弹出！</p>
<p>时间复杂度：nlogn</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heap = []</span><br><span class="line">        heapq.heappush(heap, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> ret == heap[<span class="number">0</span>]:</span><br><span class="line">                ret = heapq.heappop(heap)</span><br><span class="line">            a, b, c = ret*<span class="number">2</span>, ret*<span class="number">3</span>, ret*<span class="number">5</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c]:</span><br><span class="line">                heapq.heappush(heap, i)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.nthUglyNumber(<span class="number">9</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="313-超级丑数-堆"><a href="#313-超级丑数-堆" class="headerlink" title="313.超级丑数-堆"></a>313.超级丑数-堆</h3><p>编写一段程序来查找第 n 个超级丑数。</p>
<p>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</p>
<p><strong>示例:</strong></p>
<p>输入: n = 12, primes = [2,7,13,19]</p>
<p>输出: 32</p>
<p>解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</p>
<p><strong>说明</strong>:</p>
<p>1 是任何给定 primes 的超级丑数。</p>
<p> 给定 primes 中的数字以升序排列。</p>
<p>0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。</p>
<p>第 n 个超级丑数确保在 32 位有符整数范围内。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span><span class="params">(self, n: int, primes: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heap = []</span><br><span class="line">        heapq.heappush(heap, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> ret == heap[<span class="number">0</span>]:</span><br><span class="line">                ret = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> primes:</span><br><span class="line">                heapq.heappush(heap, ret*i)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">primes = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">19</span>]</span><br><span class="line">ret = s.nthSuperUglyNumber(<span class="number">12</span>, primes)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="347-前-K-个高频元素-堆"><a href="#347-前-K-个高频元素-堆" class="headerlink" title="347.前 K 个高频元素-堆"></a>347.前 K 个高频元素-堆</h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2</p>
<p>输出: [1,2]</p>
<p><strong>示例 2</strong>:</p>
<p>输入: nums = [1], k = 1</p>
<p>输出: [1]</p>
<p><strong>说明</strong>：</p>
<p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</p>
<p>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        num_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> num_dict:</span><br><span class="line">                num_dict[i] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            num_dict[i] += <span class="number">1</span></span><br><span class="line">        ret = sorted(num_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        ret = ret[:k]</span><br><span class="line">        ret = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> ret]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">        </span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ret = s.topKFrequent(nums, <span class="number">2</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = collections.Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ret = s.topKFrequent(nums, <span class="number">2</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="376-摆动序列-贪婪算法"><a href="#376-摆动序列-贪婪算法" class="headerlink" title="376.摆动序列-贪婪算法"></a>376.摆动序列-贪婪算法</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如, [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。</p>
<p>相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [1,7,4,9,2,5]</p>
<p>输出: 6</p>
<p>解释: 整个序列均为摆动序列。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [1,17,5,10,13,15,10,5,16,8]</p>
<p>输出: 7</p>
<p>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: [1,2,3,4,5,6,7,8,9]</p>
<p>输出: 2</p>
<p>进阶:</p>
<p>你能否用 O(n) 时间复杂度完成此题?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        max_len_list = [nums[<span class="number">0</span>]]</span><br><span class="line">        UP = <span class="literal">False</span></span><br><span class="line">        DOWN = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> UP <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                UP = <span class="literal">True</span></span><br><span class="line">                DOWN = <span class="literal">False</span></span><br><span class="line">                max_len_list.append(nums[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> UP <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 持续上升，替换为最大值</span></span><br><span class="line">                max_len_list[<span class="number">-1</span>] = nums[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> DOWN <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                DOWN = <span class="literal">True</span></span><br><span class="line">                UP = <span class="literal">False</span></span><br><span class="line">                max_len_list.append(nums[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> DOWN <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                max_len_list[<span class="number">-1</span>] = nums[i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> len(max_len_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">ret = Solution().wiggleMaxLength(nums)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="392-判断子序列-贪婪算法"><a href="#392-判断子序列-贪婪算法" class="headerlink" title="392.判断子序列-贪婪算法"></a>392.判断子序列-贪婪算法</h3><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p><strong>示例 1</strong>:</p>
<p>s = “abc”, t = “ahbgdc”</p>
<p>返回 true.</p>
<p><strong>示例 2</strong>:</p>
<p>s = “axc”, t = “ahbgdc”</p>
<p>返回 false.</p>
<p>后续挑战 :</p>
<p>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] == i:</span><br><span class="line">                s = s[<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> len(s) &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.isSubsequence(<span class="string">""</span>, <span class="string">"ahbgdc"</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="402-移掉K位数字-贪婪算法"><a href="#402-移掉K位数字-贪婪算法" class="headerlink" title="402.移掉K位数字-贪婪算法"></a>402.移掉K位数字-贪婪算法</h3><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<p>num 的长度小于 10002 且 ≥ k。</p>
<p>num 不会包含任何前导零。</p>
<p><strong>示例 1</strong> :</p>
<p>输入: num = “1432219”, k = 3</p>
<p>输出: “1219”</p>
<p>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p>
<p><strong>示例 2</strong> :</p>
<p>输入: num = “10200”, k = 1</p>
<p>输出: “200”</p>
<p>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<p><strong>示例 3</strong> :</p>
<p>输入: num = “10”, k = 2</p>
<p>输出: “0”</p>
<p>解释: 从原数字移除所有的数字，剩余为空就是0。</p>
<p>利用桟维持一个递增的序列，也就是说将字符串中字符依次入栈，</p>
<p>如果当前字符比栈顶元素小，并且还可以继续删除元素，那么就将栈顶元素移掉，且继续向下一个栈顶元素比较，尽量维持序列递增，也可以算是一个贪心思想。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(num) == k:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        stack = [num[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; num[i] <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(num[i])</span><br><span class="line">        <span class="comment"># k &gt; 0说明剩余数字为全部相同或者递增如：11111或12345</span></span><br><span class="line">        <span class="comment"># 将后k个删除即可</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            stack = stack[:-k]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> stack[<span class="number">0</span>] == <span class="string">'0'</span> <span class="keyword">and</span> len(stack) &gt; <span class="number">1</span>:</span><br><span class="line">                stack = stack[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="string">"1234560"</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">ret = Solution().removeKdigits(num, <span class="number">6</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="455-分发饼干-贪婪算法"><a href="#455-分发饼干-贪婪算法" class="headerlink" title="455.分发饼干-贪婪算法"></a>455.分发饼干-贪婪算法</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，</p>
<p>这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，</p>
<p>这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>注意：</p>
<p>你可以假设胃口值为正。</p>
<p>一个小朋友最多只能拥有一块饼干。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [1,2,3], [1,1]</p>
<p>输出: 1</p>
<p>解释:</p>
<p>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</p>
<p>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</p>
<p>所以你应该输出1。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [1,2], [1,2,3]</p>
<p>输出: 2</p>
<p>解释:</p>
<p>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</p>
<p>你拥有的饼干数量和尺寸都足以让所有孩子满足。</p>
<p>所以你应该输出2.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span><span class="params">(self, g: [int], s: [int])</span> -&gt; int:</span></span><br><span class="line">        child_list = sorted(g)  <span class="comment"># 小朋友</span></span><br><span class="line">        cookie_list = sorted(s)  <span class="comment"># 小饼干</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        child_index = <span class="number">0</span></span><br><span class="line">        cookie_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> child_index &lt; len(child_list) <span class="keyword">and</span> cookie_index &lt; len(cookie_list):</span><br><span class="line">            <span class="keyword">if</span> cookie_list[cookie_index] &gt;= child_list[child_index]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">                child_index += <span class="number">1</span></span><br><span class="line">            cookie_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.findContentChildren([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="703-数据流中的第K大元素-堆"><a href="#703-数据流中的第K大元素-堆" class="headerlink" title="703.数据流中的第K大元素-堆"></a>703.数据流中的第K大元素-堆</h3><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p>
<p>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>];</span><br><span class="line">KthLargest kthLargest = <span class="keyword">new</span> KthLargest(<span class="number">3</span>, arr);</span><br><span class="line">kthLargest.add(<span class="number">3</span>);  <span class="comment">// returns 4</span></span><br><span class="line">kthLargest.add(<span class="number">5</span>);  <span class="comment">// returns 5</span></span><br><span class="line">kthLargest.add(<span class="number">10</span>); <span class="comment">// returns 5</span></span><br><span class="line">kthLargest.add(<span class="number">9</span>);  <span class="comment">// returns 8</span></span><br><span class="line">kthLargest.add(<span class="number">4</span>);  <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure>

<p>执行用时 :120 ms, 在所有 python3 提交中击败了95.49%的用户</p>
<p>内存消耗 :17.4 MB, 在所有 python3 提交中击败了5.63%的用户</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int, nums: [int])</span>:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums = nums[:k]</span><br><span class="line">        heapq.heapify(self.nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> i &gt; self.nums[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(self.nums)</span><br><span class="line">                heapq.heappush(self.nums, i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="keyword">if</span> len(self.nums) &lt; self.k:</span><br><span class="line">            heapq.heappush(self.nums, val)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.nums[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappop(self.nums)</span><br><span class="line">            heapq.heappush(self.nums, val)</span><br><span class="line">        <span class="keyword">return</span> self.nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">s = KthLargest(k, arr)</span><br><span class="line">ret = s.add(<span class="number">3</span>)</span><br><span class="line">print(ret)  <span class="comment"># 4</span></span><br><span class="line">ret = s.add(<span class="number">5</span>)</span><br><span class="line">print(ret)  <span class="comment"># 5</span></span><br><span class="line">ret = s.add(<span class="number">10</span>)</span><br><span class="line">print(ret)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<h3 id="1021-删除最外层的括号-栈"><a href="#1021-删除最外层的括号-栈" class="headerlink" title="1021.删除最外层的括号-栈"></a>1021.删除最外层的括号-栈</h3><p>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
<p><strong>示例 1</strong>：</p>
<p>输入：”(()())(())”</p>
<p>输出：”()()()”</p>
<p>解释：</p>
<p>输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，</p>
<p>删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。</p>
<p><strong>示例 2</strong>：</p>
<p>输入：”(()())(())(()(()))”</p>
<p>输出：”()()()()(())”</p>
<p>解释：</p>
<p>输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，</p>
<p>删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。</p>
<p><strong>示例 3</strong>：</p>
<p>输入：”()()”</p>
<p>输出：””</p>
<p>解释：</p>
<p>输入字符串为 “()()”，原语化分解得到 “()” + “()”，</p>
<p>删除每个部分中的最外层括号后得到 “” + “” = “”。</p>
<p><strong>提示</strong>：</p>
<p>S.length &lt;= 10000</p>
<p>S[i] 为 “(“ 或 “)”</p>
<p>S 是一个有效括号字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeOuterParentheses</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        ret_str = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">if</span>(len(stack) &gt;= <span class="number">1</span>):</span><br><span class="line">                    ret_str += i</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># i == ')'</span></span><br><span class="line">                <span class="keyword">if</span>(len(stack) &gt; <span class="number">1</span>):</span><br><span class="line">                    ret_str += i</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> ret_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">s_test = <span class="string">"(()())(())(()(()))"</span></span><br><span class="line">print(s.removeOuterParentheses(s_test))</span><br></pre></td></tr></table></figure>

<h3 id="1047-删除字符串中的所有相邻重复项-栈"><a href="#1047-删除字符串中的所有相邻重复项-栈" class="headerlink" title="1047.删除字符串中的所有相邻重复项-栈"></a>1047.删除字符串中的所有相邻重复项-栈</h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例</strong>：</p>
<p>输入：”abbaca”</p>
<p>输出：”ca”</p>
<p>解释：</p>
<p>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p>
<p><strong>提示</strong>：</p>
<p>1 &lt;= S.length &lt;= 20000</p>
<p>S 仅由小写英文字母组成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == i:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        ret_str = <span class="string">''</span>.join(stack)</span><br><span class="line">        <span class="keyword">return</span> ret_str</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.removeDuplicates(<span class="string">"abbaca"</span>))</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/10/22/hexo/" rel="next" title="hexo">
                  <i class="fa fa-chevron-left"></i> hexo
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode"><span class="nav-text">LeetCode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-两数之和"><span class="nav-text">1.两数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-两数相加"><span class="nav-text">2.两数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-无重复字符的最长子串"><span class="nav-text">3.无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-最长回文子串-动态规划"><span class="nav-text">5. 最长回文子串-动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-整数反转"><span class="nav-text">7. 整数反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-字符串转换整数-atoi"><span class="nav-text">8. 字符串转换整数 (atoi)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-回文数"><span class="nav-text">9. 回文数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-罗马数字转整数"><span class="nav-text">13. 罗马数字转整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-最长公共前缀"><span class="nav-text">14. 最长公共前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-有效的括号-栈"><span class="nav-text">20.有效的括号-栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-合并两个有序链表"><span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-删除排序数组中的重复项"><span class="nav-text">26. 删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-移除元素"><span class="nav-text">27. 移除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-最大子序和-动态规划"><span class="nav-text">53. 最大子序和-动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-跳跃游戏-贪婪算法"><span class="nav-text">55.跳跃游戏-贪婪算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-不同路径-动态规划"><span class="nav-text">62. 不同路径-动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-不同路径II"><span class="nav-text">63.不同路径II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-最小路径和"><span class="nav-text">64. 最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70-爬楼梯"><span class="nav-text">70. 爬楼梯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#71-简化路径-栈"><span class="nav-text">71.简化路径-栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-二叉树的中序遍历"><span class="nav-text">94.二叉树的中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-买卖股票的最佳时机-II-贪婪算法"><span class="nav-text">122.买卖股票的最佳时机 II-贪婪算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#134-加油站-贪婪算法"><span class="nav-text">134.加油站-贪婪算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#215-数组中的第K个最大元素-堆"><span class="nav-text">215.数组中的第K个最大元素-堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#264-丑数II-堆"><span class="nav-text">264.丑数II-堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#313-超级丑数-堆"><span class="nav-text">313.超级丑数-堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347-前-K-个高频元素-堆"><span class="nav-text">347.前 K 个高频元素-堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#376-摆动序列-贪婪算法"><span class="nav-text">376.摆动序列-贪婪算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#392-判断子序列-贪婪算法"><span class="nav-text">392.判断子序列-贪婪算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#402-移掉K位数字-贪婪算法"><span class="nav-text">402.移掉K位数字-贪婪算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#455-分发饼干-贪婪算法"><span class="nav-text">455.分发饼干-贪婪算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#703-数据流中的第K大元素-堆"><span class="nav-text">703.数据流中的第K大元素-堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1021-删除最外层的括号-栈"><span class="nav-text">1021.删除最外层的括号-栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1047-删除字符串中的所有相邻重复项-栈"><span class="nav-text">1047.删除字符串中的所有相邻重复项-栈</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="scola"
    src="/images/xiamu.jpg">
  <p class="site-author-name" itemprop="name">scola</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">scola</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.2
  </div>

        






  
  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=j86GER21RDJrgx9rIKsTpeB0-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'j86GER21RDJrgx9rIKsTpeB0-gzGzoHsz',
            'X-LC-Key': '7xyNNqCme3v6eUf736HftKuE',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/muse.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  






  <script src="/js/local-search.js?v=7.4.2"></script>













  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'j86GER21RDJrgx9rIKsTpeB0-gzGzoHsz',
    appKey: '7xyNNqCme3v6eUf736HftKuE',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
