<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>随手记</title>
    <url>/2019/12/26/chaos/</url>
    <content><![CDATA[<p>别在这种地方摸鱼，快去拯救世界吧！</p>
<p><img src="/2019/12/26/chaos/five.jpg" alt></p>
<a id="more"></a>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2019/12/26/Linux%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Linux笔记"><a href="#Linux笔记" class="headerlink" title="Linux笔记"></a>Linux笔记</h2><p>本篇博客用于记录在Linux学习过程中遇到的问题、常用的工具等。</p>
<a id="more"></a>

<h3 id="1-Ubuntu下pip和sudo-pip路径指向修改"><a href="#1-Ubuntu下pip和sudo-pip路径指向修改" class="headerlink" title="1.Ubuntu下pip和sudo pip路径指向修改"></a>1.Ubuntu下pip和sudo pip路径指向修改</h3><p><strong>查看现有pip路径指向</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@sxj-VirtualBox:/home/sxj# pip -V</span><br><span class="line">pip 1.5.1 from /usr/lib/python2.7/dist-packages/pip (python 2.7)</span><br></pre></td></tr></table></figure>

<p> <strong>pip位置修改</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打开bash文件修改</span></span><br><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash">在最后一行添加如下命令：</span></span><br><span class="line">alias pip=/usr/local/bin/pip</span><br><span class="line"><span class="meta">#</span><span class="bash">更新bash文件</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p> <strong>sudo pip位置修改</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改etc目录</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">在最后一行添加如下命令：</span></span><br><span class="line">alias pip=/usr/local/bin/pip</span><br><span class="line"><span class="meta">#</span><span class="bash">保存退出后，使用如下更新命令</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>参考： <a href="https://blog.csdn.net/mecong/article/details/90453111" target="_blank" rel="noopener">https://blog.csdn.net/mecong/article/details/90453111</a> </p>
<h3 id="2-Ubuntu14更换apt-get源"><a href="#2-Ubuntu14更换apt-get源" class="headerlink" title="2.Ubuntu14更换apt-get源"></a>2.Ubuntu14更换apt-get源</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.备份</span></span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="comment"># 2.将如下写入source.list</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># 3.更新apt-get</span></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="3-Ubuntu更换pip源"><a href="#3-Ubuntu更换pip源" class="headerlink" title="3.Ubuntu更换pip源"></a>3.Ubuntu更换pip源</h3><p><strong>pip国内的一些镜像</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">阿里云         http://mirrors.aliyun.com/pypi/simple/ </span><br><span class="line">中国科技大学    https://pypi.mirrors.ustc.edu.cn/simple/ </span><br><span class="line">豆瓣(douban)   http://pypi.douban.com/simple/ </span><br><span class="line">清华大学        https://pypi.tuna.tsinghua.edu.cn/simple/ </span><br><span class="line">中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure>

<p><strong>修改源方法：</strong></p>
<p><strong>临时使用：</strong><br>可以在使用pip的时候在后面加上-i参数，指定pip源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p><strong>永久修改：</strong><br>        <strong>linux:</strong><br>修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h3 id="4-MTR网络诊断工具简单使用"><a href="#4-MTR网络诊断工具简单使用" class="headerlink" title="4.MTR网络诊断工具简单使用"></a>4.MTR网络诊断工具简单使用</h3><p> <a href="http://www.bitwizard.nl/mtr/" target="_blank" rel="noopener">MTR</a>是一个功能强大的工具，使管理员能够诊断和隔离网络错误，并向上游提供商提供网络状态报告。MTR表示的演进<code>traceroute</code>通过提供更大的数据样本，好像增强命令<code>traceroute</code>与<code>ping</code>输出 </p>
<p><strong>安装MTR</strong></p>
<p><strong>Ubuntu</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install mtr-tiny</span><br></pre></td></tr></table></figure>

<p><strong>Centos</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mtr</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<blockquote>
<p>mtr google.com可实时查看当前网络状况</p>
<p>-r 标志生成报告（为–report所写） </p>
<p>-w 选项标志使用长版本的主机名，您可以看到每个跳的完整主机名（–report-wide的缩写）</p>
<p>-c 选项标志设置报告中发送和记录的数据包数量。当不使用时，默认值通常为 10，但是对于更快的间隔，您可能希望将其设置为 50 或 100.报告可能需要较长时间才能完成</p>
<p>-i 选项标志以更快的速率运行报告，以显示只能在网络拥塞期间发生的数据包丢失。该标志指示 MTR 每n秒发送一个数据包。默认值为1秒，因此将其设置为十分之一秒（0.1，0.2等）通常是有帮助的</p>
</blockquote>
<p><strong>读懂 MTR 报告</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]# mtr -r google.com</span><br><span class="line">Start: Thu Dec 26 09:32:31 2019</span><br><span class="line">HOST: centos7                     Loss%   Snt   Last   Avg  Best  Wrst StDev</span><br><span class="line">  1.|-- 100.96.0.1                 0.0%    10   52.5  36.8   9.8  52.5  18.5</span><br><span class="line">  2.|-- 10.35.5.73                 0.0%    10   52.3  42.6   6.3  52.4  16.8</span><br><span class="line">  3.|-- 10.38.6.105                0.0%    10   52.4  47.6   2.7  57.9  16.0</span><br><span class="line">  4.|-- 10.38.5.38                70.0%    10   52.4  59.0  52.4  71.9  11.2</span><br><span class="line">  5.|-- ???                       100.0    10    0.0   0.0   0.0   0.0   0.0</span><br><span class="line">  6.|-- ???                       100.0    10    0.0   0.0   0.0   0.0   0.0</span><br><span class="line">  7.|-- 10.38.5.25                 0.0%    10   53.0  42.5   7.3  56.0  17.9</span><br><span class="line">  8.|-- 10.38.6.190                0.0%    10    1.6   2.1   1.6   5.4   1.0</span><br><span class="line">  9.|-- 10.1.1.137                 0.0%    10    2.1   3.1   2.1   8.9   2.2</span><br><span class="line"> 10.|-- 10.1.0.113                 0.0%    10    2.3   2.3   2.2   2.6   0.0</span><br><span class="line"> 11.|-- 61.48.56.209              10.0%    10   38.1  28.9   5.7  55.8  18.5</span><br><span class="line"> 12.|-- 123.126.0.157              0.0%    10    5.9   5.9   4.3   7.7   1.1</span><br><span class="line"> 13.|-- 202.96.12.61               0.0%    10    8.3   7.4   4.1  10.2   1.9</span><br><span class="line"> 14.|-- ???                       100.0    10    0.0   0.0   0.0   0.0   0.0</span><br></pre></td></tr></table></figure>

<p>返回结果各列数据说明：</p>
<p>第一列: 显示的是 IP 地址或本机域名，这点和 traceroute 很像</p>
<p>第二列: <strong>Loss%</strong> 到达此节点的数据包丢包率，显示的每个对应 IP 的丢包率。</p>
<p>第三列: <strong>Snt</strong>:100 设置发送数据包的数量，默认值是 10 通过参数 -c 来自定义数量。</p>
<p>第四列: <strong>Last</strong> 显示的最近一次的返回时延</p>
<p>第五列: <strong>Avg</strong> 平均值这个应该是发送 ping 包的平均时延</p>
<p>第六列: <strong>Best</strong> 最好或者说时延最低的</p>
<p>第七列: <strong>Wrst</strong> 最差或者说时延最大的</p>
<p>第八列: <strong>StDev</strong> 是标准偏差</p>
<h3 id="5-netstat简介"><a href="#5-netstat简介" class="headerlink" title="5.netstat简介"></a>5.netstat简介</h3><p> <strong><code>netstat</code></strong>是一个基于<a href="https://zh.wikipedia.org/wiki/命令行界面" target="_blank" rel="noopener">命令行界面</a>的<a href="https://zh.wikipedia.org/wiki/计算机网络" target="_blank" rel="noopener">网络</a><a href="https://zh.wikipedia.org/wiki/实用程序" target="_blank" rel="noopener">实用工具</a>，可显示当前的网络状态，包括<a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">传输控制协议</a>层的连线状况、<a href="https://zh.wikipedia.org/wiki/路由表" target="_blank" rel="noopener">路由表</a>、<a href="https://zh.wikipedia.org/wiki/网络接口" target="_blank" rel="noopener">网络接口</a>状态和<a href="https://zh.wikipedia.org/wiki/网络协议" target="_blank" rel="noopener">网络协议</a>的统计信息等。</p>
<p><strong>常见参数</strong></p>
<blockquote>
<p>-a (all)显示所有选项，默认不显示LISTEN相关</p>
<p>-t (tcp)仅显示tcp相关选项</p>
<p>-u (udp)仅显示udp相关选项</p>
<p>-n 拒绝显示别名，能显示数字的全部转化成数字。</p>
<p>-l 仅列出有在 Listen (监听) 的服務状态</p>
<p>-p 显示建立相关链接的程序名</p>
<p>-r 显示路由信息，路由表</p>
<p>-e 显示扩展信息，例如uid等</p>
<p>-s 按各个协议进行统计</p>
<p>-c 每隔一个固定时间，执行该netstat命令。 </p>
</blockquote>
<p><strong>示例</strong></p>
<p><img src="/2019/12/26/Linux%E7%AC%94%E8%AE%B0/netstat.png" alt></p>
<p><strong>Proto</strong>： 协议（TCP/UDP）</p>
<p><strong>Local Address</strong> ：本地地址: 端口</p>
<p><strong>Foreign Address</strong>：外部地址: 端口　</p>
<p><strong>State</strong>:　内部地址与外部地址的连接状态 </p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL触发器</title>
    <url>/2019/12/26/mysql_trigger/</url>
    <content><![CDATA[<h1 id="Mysql触发器"><a href="#Mysql触发器" class="headerlink" title="Mysql触发器"></a>Mysql触发器</h1><h3 id="什么是触发器"><a href="#什么是触发器" class="headerlink" title="什么是触发器"></a>什么是触发器</h3><p>触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。</p>
<h3 id="创建触发器的语法"><a href="#创建触发器的语法" class="headerlink" title="创建触发器的语法"></a>创建触发器的语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tb_name FOR EACH ROW trigger_stmt;</span><br><span class="line"></span><br><span class="line">-- 字段解析</span><br><span class="line">trigger_name：触发器的名称</span><br><span class="line">tirgger_time：触发时机，为BEFORE或者AFTER</span><br><span class="line">trigger_event：触发事件，为INSERT、DELETE或者UPDATE</span><br><span class="line">tb_name：表示建立触发器的表明，就是在哪张表上建立触发器</span><br><span class="line">trigger_stmt：触发器的程序体，可以是一条SQL语句或者是用BEGIN和END包含的多条语句</span><br><span class="line"></span><br><span class="line">所以可以说MySQL创建以下六种触发器：</span><br><span class="line">BEFORE INSERT,BEFORE DELETE,BEFORE UPDATE</span><br><span class="line">AFTER INSERT,AFTER DELETE,AFTER UPDATE</span><br></pre></td></tr></table></figure>

<p><strong>创建有多个执行语句的触发器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件</span><br><span class="line">ON 表名 FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    执行语句列表</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>其中，BEGIN与END之间的执行语句列表参数表示需要执行的多个语句，不同语句用分号隔开</p>
<p><strong>tips：</strong>一般情况下，mysql默认是以 ; 作为结束执行语句，与触发器中需要的分行起冲突</p>
<p>　　  为解决此问题可用DELIMITER，如：DELIMITER ||，可以将结束符号变成||</p>
<p>　　  当触发器创建完成后，可以用DELIMITER ;来将结束符号变成;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELIMITER ||</span><br><span class="line">mysql&gt; CREATE TRIGGER demo BEFORE DELETE</span><br><span class="line">    -&gt; ON users FOR EACH ROW</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; INSERT INTO logs VALUES(NOW());</span><br><span class="line">    -&gt; INSERT INTO logs VALUES(NOW());</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; ||</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure>

<p><strong>触发器类型</strong></p>
<table>
<thead>
<tr>
<th align="left">触发器类型</th>
<th align="left">激活触发器的语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INSERT型触发器</td>
<td align="left">INSERT, LOAD DATA, REPLACE</td>
</tr>
<tr>
<td align="left">Y</td>
<td align="left">UPDATE</td>
</tr>
<tr>
<td align="left">DELETE型触发器</td>
<td align="left">DELETE, REPLACE</td>
</tr>
</tbody></table>
<p><strong>NEW和OLD的使用</strong></p>
<table>
<thead>
<tr>
<th align="left">触发器类型</th>
<th align="left">激活触发器的语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INSERT型触发器</td>
<td align="left">NEW表示将要或者已经新增的数据</td>
</tr>
<tr>
<td align="left">UPDATE型触发器</td>
<td align="left">OLD用来表示将要或者已经被删除的语句，NEW表示将要或者已经修改的数据</td>
</tr>
<tr>
<td align="left">DELETE型触发器</td>
<td align="left">OLD表示将要或者已经被删除的数据</td>
</tr>
</tbody></table>
<h3 id="触发器的应用举例"><a href="#触发器的应用举例" class="headerlink" title="触发器的应用举例"></a>触发器的应用举例</h3><p>例如需要存储大量的URL，并需要根据URL进行搜索查找。如果使用B-Tree来存储URL，存储的内容就会很大，因为URL本身都很长。而且对完整的URL字符串做索引会非常慢。正常情况下会有如下查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM url WHERE url=&quot;https://scooola.github.io&quot;;</span><br></pre></td></tr></table></figure>

<p>若删除原来URL列上的索引，而新增一个被索引的url_crc列，使用CRC32做哈希，就可以使用下面的方式查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM url WHERE url=&quot;https://scooola.github.io&quot; AND url_cc=CRC32(&quot;https://scooola.github.io&quot;);</span><br></pre></td></tr></table></figure>

<p>这样做的性能会非常高，因为MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引来完成查找。</p>
<p>这样实现的缺陷是需要维护哈希值。可以手动维护，也可以使用触发器实现。首先创建如下表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE pseudohash (</span><br><span class="line">    -&gt; id int NOT NULL auto_increment,</span><br><span class="line">    -&gt; url varchar(255) NOT NULL,</span><br><span class="line">    -&gt; url_crc int NOT NULL DEFAULT 0,</span><br><span class="line">    -&gt; PRIMARY KEY(id)</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure>

<p><strong>创建触发器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 新增数据触发器</span><br><span class="line">CREATE TRIGGER pseudohash_crc_ins INSERT UPDATE ON pseudohash FOR EACH ROW SET NEW.url_crc=crc32(NEW.url);</span><br><span class="line">-- 更新数据触发器</span><br><span class="line">CREATE TRIGGER pseudohash_crc_upd BEFORE UPDATE ON pseudohash FOR EACH ROW SET NEW.url_crc=crc32(NEW.url);</span><br></pre></td></tr></table></figure>

<p>接下来验证一下触发器如何维护哈希索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 新增</span><br><span class="line">mysql&gt; INSERT INTO pseudohash (url) VALUES(&apos;https://scooola.github.io&apos;);</span><br><span class="line">mysql&gt; SELECT * FROM pseudohash;</span><br><span class="line">+----+---------------------------+----------+</span><br><span class="line">| id | url                       | url_crc  |</span><br><span class="line">+----+---------------------------+----------+</span><br><span class="line">|  1 | https://scooola.github.io | 47105892 |</span><br><span class="line">+----+---------------------------+----------+</span><br><span class="line"></span><br><span class="line">-- 更新</span><br><span class="line">mysql&gt; UPDATE pseudohash SET url=&apos;https://scooola.github.io/&apos; WHERE id=1;</span><br><span class="line">mysql&gt; SELECT * FROM pseudohash;</span><br><span class="line">+----+----------------------------+-----------+</span><br><span class="line">| id | url                        | url_crc   |</span><br><span class="line">+----+----------------------------+-----------+</span><br><span class="line">|  1 | https://scooola.github.io/ | 856602962 |</span><br><span class="line">+----+----------------------------+-----------+</span><br></pre></td></tr></table></figure>

<p>如果数据表非常大，CRC32()会出现大量的哈希冲突，可以考虑自己实现一个简单的64位哈希函数。</p>
<p>上述示例中，就用触发器来维护了哈希索引的生成，而避免的程序主动生成触发。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2019/11/06/LeetCode/</url>
    <content><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p>最近在学习python3，便想到了用python3刷LeetCode，既可以学习到python3的一些语法细节，也可以锻炼算法能力。</p>
<p>刷题未完全按照LeetCode排列顺序去刷，但是排布会按照题号大小去排列。算法小白，大佬看到勿喷。</p>
<a id="more"></a>

<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]</p>
<p>执行用时 :64 ms, 在所有 python3 提交中击败了93.62%的用户<br>        内存消耗 :15.5 MB, 在所有 python3 提交中击败了5.05%的用户</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            num_dict[value] = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            v = num_dict.get(target-value)</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> v != index:</span><br><span class="line">                <span class="keyword">return</span>[index, v]</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">target = <span class="number">6</span></span><br><span class="line">print(s.twoSum(nums, target))</span><br></pre></td></tr></table></figure>

<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>        输出：7 -&gt; 0 -&gt; 8<br>        原因：342 + 465 = 807</p>
<p>执行用时 :72 ms, 在所有 python3 提交中击败了98.47%的用户<br>        内存消耗 :13.8 MB, 在所有 python3 提交中击败了5.06%的用户</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        base = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = base</span><br><span class="line">        curry = <span class="number">0</span>  <span class="comment"># 两数相加，大于10时的十位，即进位，需在下一位加上该值</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            sum = l1.val + l2.val + curry</span><br><span class="line">            index = sum % <span class="number">10</span></span><br><span class="line">            tmp.next = ListNode(index)</span><br><span class="line">            curry = sum // <span class="number">10</span></span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            sum = l1.val + curry</span><br><span class="line">            index = sum % <span class="number">10</span></span><br><span class="line">            tmp.next = ListNode(index)</span><br><span class="line">            curry = sum // <span class="number">10</span></span><br><span class="line">            l1 = l1.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            sum = l2.val + curry</span><br><span class="line">            index = sum % <span class="number">10</span></span><br><span class="line">            tmp.next = ListNode(index)</span><br><span class="line">            curry = sum // <span class="number">10</span></span><br><span class="line">            l2 = l2.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>):</span><br><span class="line">            tmp.next = ListNode(sum//<span class="number">10</span>)</span><br><span class="line">        base = base.next</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="comment"># l1 = 342</span></span><br><span class="line">l1 = ListNode(<span class="number">2</span>)</span><br><span class="line">l1_next = l1.next = ListNode(<span class="number">4</span>)</span><br><span class="line">l1_next.next = ListNode(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># l2 = 465</span></span><br><span class="line">l2 = ListNode(<span class="number">5</span>)</span><br><span class="line">l2_next = l2.next = ListNode(<span class="number">6</span>)</span><br><span class="line">l2_next.next = ListNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># l1 + l2 = 807</span></span><br><span class="line">ret = s.addTwoNumbers(l1, l2)</span><br><span class="line"><span class="keyword">while</span> ret:</span><br><span class="line">    print(<span class="string">"ret:"</span>, ret.val)</span><br><span class="line">    ret = ret.next</span><br></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “abcabcbb”</p>
<p>输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “bbbb”</p>
<p>输出: 1</p>
<p>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “pwwkew”</p>
<p>输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p>
<p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴力解法，两层for循环</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            tmp_list = []</span><br><span class="line">            tmp_list.append(s[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> tmp_list:</span><br><span class="line">                    tmp_list.append(s[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> len(tmp_list) &gt; max_len:</span><br><span class="line">                max_len = len(tmp_list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<p><strong>思路优化</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(num) == k:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        stack = [num[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; num[i] <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(num[i])</span><br><span class="line">        <span class="comment"># k &gt; 0说明剩余数字为全部相同或者递增如：11111或12345</span></span><br><span class="line">        <span class="comment"># 将后k个删除即可</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            stack = stack[:-k]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> stack[<span class="number">0</span>] == <span class="string">'0'</span> <span class="keyword">and</span> len(stack) &gt; <span class="number">1</span>:</span><br><span class="line">                stack = stack[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="string">"1234560"</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">ret = Solution().removeKdigits(num, <span class="number">6</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="5-最长回文子串-动态规划"><a href="#5-最长回文子串-动态规划" class="headerlink" title="5. 最长回文子串-动态规划"></a>5. 最长回文子串-动态规划</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p><strong>示例 1</strong>：</p>
<p>输入: “babad”</p>
<p>输出: “bab”</p>
<p>注意: “aba” 也是一个有效答案。</p>
<p><strong>示例 2</strong>：</p>
<p>输入: “cbbd”</p>
<p>输出: “bb”</p>
<p><strong>暴力解法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        result = s[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)):</span><br><span class="line">                is_back_to_text = self.isBackTotext(s, i, j)</span><br><span class="line">                <span class="keyword">if</span> is_back_to_text <span class="keyword">and</span> j - i + <span class="number">1</span> &gt; max_len:</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    result = s[i:j+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBackTotext</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>动态规划</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            str1 = self.getLongestPalindrome(s, i, i)</span><br><span class="line">            <span class="keyword">if</span> len(str1) &gt;len(result):</span><br><span class="line">                result = str1</span><br><span class="line">            str2 = self.getLongestPalindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> len(str2) &gt;len(result):</span><br><span class="line">                result = str2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLongestPalindrome</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s[left+<span class="number">1</span>:right]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"babad"</span></span><br><span class="line">ret = Solution().longestPalindrome(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: 123</p>
<p>输出: 321</p>
<p> <strong>示例 2</strong>:</p>
<p>输入: -123</p>
<p>输出: -321</p>
<p><strong>示例 3</strong>:</p>
<p>输入: 120</p>
<p>输出: 21</p>
<p>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>例如：</p>
<p>在python中 ：-53除以10=-6 …7 所以python中 -53%10=7</p>
<p>在c语言中，-53除以10=-5 … -3 所以c语言中 -53%10=-3</p>
<p>（python3中， /是精确除法，//是向下取整除法，%是求模，四舍五入取整round, 向零取整int, 向下和向上取整函数math.floor, math.ceil）</p>
<p><strong>解法一</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        tmp = x</span><br><span class="line">        <span class="keyword">if</span> tmp &lt; <span class="number">0</span>:</span><br><span class="line">            tmp = -tmp</span><br><span class="line">        str_tmp = str(tmp)</span><br><span class="line">        str_tmp = str_tmp[::<span class="number">-1</span>]</span><br><span class="line">        int_tmp = int(str_tmp)</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            int_tmp = -int_tmp</span><br><span class="line">        <span class="keyword">if</span> int_tmp &lt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> int_tmp &gt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> int_tmp</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            num = -x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = x</span><br><span class="line">        num_list = []</span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            tmp = num % <span class="number">10</span></span><br><span class="line">            num_list.append(tmp)</span><br><span class="line">            num = num // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        num_list.reverse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> num_list:</span><br><span class="line">            tmp = num_list.pop()</span><br><span class="line">            num = num * <span class="number">10</span> + tmp</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            num = -num</span><br><span class="line">        <span class="keyword">if</span> num &lt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> num &gt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().reverse(<span class="number">-123</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h3><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明</strong>：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2<strong>31, 2</strong>31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2<strong>31 − 1) 或 INT_MIN (−2</strong>31) 。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “42”</p>
<p>输出: 42</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “  -42”</p>
<p>输出: -42</p>
<p>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。</p>
<p>   我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “4193 with words”</p>
<p>输出: 4193</p>
<p>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
<p><strong>示例 4</strong>:</p>
<p>输入: “words and 987”</p>
<p>输出: 0</p>
<p>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。</p>
<p>   因此无法执行有效的转换。</p>
<p><strong>示例 5</strong>:</p>
<p>输入: “-91283472332”</p>
<p>输出: -2147483648</p>
<p>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。</p>
<p>   因此返回 INT_MIN (−2**31) 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, strs: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> strs == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        size = len(strs)</span><br><span class="line">        num_list = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        nums = set(str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="keyword">if</span> strs[i] == <span class="string">' '</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> strs[i] == <span class="string">'-'</span> <span class="keyword">or</span> strs[i] == <span class="string">'+'</span> <span class="keyword">or</span> strs[i] <span class="keyword">in</span> nums:</span><br><span class="line">                index = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            num_list.append(strs[index])</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= size <span class="keyword">or</span> strs[index] <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        ret_str = <span class="string">""</span>.join(num_list)</span><br><span class="line">        <span class="keyword">if</span> len(ret_str) == <span class="number">1</span> <span class="keyword">and</span> ret_str[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ret_num = int(ret_str)</span><br><span class="line">        <span class="keyword">if</span> ret_num &lt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> ret_num &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> ret_num &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2147483648</span></span><br><span class="line">        <span class="keyword">return</span> ret_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"2147483648"</span></span><br><span class="line">ret = Solution().myAtoi(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: 121</p>
<p>输出: true</p>
<p><strong>示例 2</strong>:</p>
<p>输入: -121</p>
<p>输出: false</p>
<p>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: 10</p>
<p>输出: false</p>
<p>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
<p>进阶:</p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        num = x</span><br><span class="line">        new_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            tmp_num = num % <span class="number">10</span></span><br><span class="line">            new_num = new_num * <span class="number">10</span> + tmp_num</span><br><span class="line">            num = num // <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> new_num == x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">121</span></span><br><span class="line">ret = Solution().isPalindrome(num)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">500</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">1000</td>
</tr>
</tbody></table>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。</p>
<p>同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</p>
<p>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </p>
<p>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “III”</p>
<p>输出: 3</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “IV”</p>
<p>输出: 4</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “IX”</p>
<p>输出: 9</p>
<p><strong>示例 4</strong>:</p>
<p>输入: “LVIII”</p>
<p>输出: 58</p>
<p>解释: L = 50, V= 5, III = 3.</p>
<p><strong>示例 5</strong>:</p>
<p>输入: “MCMXCIV”</p>
<p>输出: 1994</p>
<p>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴力解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        num_dict = dict(I=<span class="number">1</span>, V=<span class="number">5</span>, X=<span class="number">10</span>, L=<span class="number">50</span>, C=<span class="number">100</span>, D=<span class="number">500</span>, M=<span class="number">1000</span>, IV=<span class="number">4</span>, IX=<span class="number">9</span>, XL=<span class="number">40</span>, XC=<span class="number">90</span>, CD=<span class="number">400</span>, CM=<span class="number">900</span>)</span><br><span class="line">        num_list = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> i == (len(s) - <span class="number">1</span>):</span><br><span class="line">                num_list.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'I'</span> <span class="keyword">and</span> (s[i+<span class="number">1</span>] == <span class="string">'V'</span> <span class="keyword">or</span> s[i+<span class="number">1</span>] == <span class="string">'X'</span>):</span><br><span class="line">                tmp = s[i] + s[i+<span class="number">1</span>]</span><br><span class="line">                num_list.append(tmp)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'X'</span> <span class="keyword">and</span> (s[i+<span class="number">1</span>] == <span class="string">'L'</span> <span class="keyword">or</span> s[i+<span class="number">1</span>] == <span class="string">'C'</span>):</span><br><span class="line">                tmp = s[i] + s[i+<span class="number">1</span>]</span><br><span class="line">                num_list.append(tmp)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'C'</span> <span class="keyword">and</span> (s[i+<span class="number">1</span>] == <span class="string">'D'</span> <span class="keyword">or</span> s[i+<span class="number">1</span>] == <span class="string">'M'</span>):</span><br><span class="line">                tmp = s[i] + s[i+<span class="number">1</span>]</span><br><span class="line">                num_list.append(tmp)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num_list.append(s[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">            num = num + num_dict[i]</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

<p><strong>优化-但速度并未明显提升</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        num_dict = dict(I=<span class="number">1</span>, V=<span class="number">5</span>, X=<span class="number">10</span>, L=<span class="number">50</span>, C=<span class="number">100</span>, D=<span class="number">500</span>, M=<span class="number">1000</span>, IV=<span class="number">4</span>, IX=<span class="number">9</span>, XL=<span class="number">40</span>, XC=<span class="number">90</span>, CD=<span class="number">400</span>, CM=<span class="number">900</span>)</span><br><span class="line">        num_set = set((<span class="string">'I'</span>, <span class="string">'V'</span>, <span class="string">'X'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'M'</span>, <span class="string">'IV'</span>, <span class="string">'IX'</span>, <span class="string">'XL'</span>, <span class="string">'XC'</span>, <span class="string">'CD'</span>, <span class="string">'CM'</span>))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> index+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[index]+s[index+<span class="number">1</span>] <span class="keyword">in</span> num_set:</span><br><span class="line">                num = num + num_dict[s[index] + s[index+<span class="number">1</span>]]</span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = num + num_dict[s[index]]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"MCMXCIV"</span></span><br><span class="line">ret = Solution().romanToInt(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [“flower”,”flow”,”flight”]</p>
<p>输出: “fl”</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [“dog”,”racecar”,”car”]</p>
<p>输出: “”</p>
<p>解释: 输入不存在公共前缀。</p>
<p><strong>说明</strong>:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: [str])</span> -&gt; str:</span></span><br><span class="line">        size = len(strs)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先找出前两个的公共前缀</span></span><br><span class="line">        <span class="comment"># 若存在，则用该前缀与后续str比较</span></span><br><span class="line">        <span class="comment"># 若不存在，则直接返回""</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> strs[<span class="number">0</span>] == <span class="string">""</span> <span class="keyword">or</span> strs[<span class="number">1</span>] == <span class="string">""</span> <span class="keyword">or</span> strs[<span class="number">0</span>][<span class="number">0</span>] != strs[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(strs[<span class="number">0</span>]) <span class="keyword">and</span> index &lt; len(strs[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> strs[<span class="number">0</span>][index] == strs[<span class="number">1</span>][index]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        public_str = strs[<span class="number">0</span>][:index]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, size):</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 判断首位是否相同，不同直接返回""</span></span><br><span class="line">            <span class="keyword">if</span> strs[i] == <span class="string">""</span> <span class="keyword">or</span> public_str[index] != strs[i][index]:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; len(public_str) <span class="keyword">and</span> index &lt; len(strs[i]):</span><br><span class="line">                <span class="keyword">if</span> public_str[index] == strs[i][index]:</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            public_str = public_str[<span class="number">0</span>:index]</span><br><span class="line">        <span class="keyword">return</span> public_str</span><br></pre></td></tr></table></figure>

<p><strong>大神解法</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: [str])</span> -&gt; str:</span></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> zip(*strs):</span><br><span class="line">            <span class="keyword">if</span> len(set(i)) == <span class="number">1</span>:</span><br><span class="line">                s += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">strs = [<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>]</span><br><span class="line">ret = Solution().longestCommonPrefix(strs)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="20-有效的括号-栈"><a href="#20-有效的括号-栈" class="headerlink" title="20.有效的括号-栈"></a>20.有效的括号-栈</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。</p>
<p>左括号必须以正确的顺序闭合。</p>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: “()”</p>
<p>输出: true</p>
<p><strong>示例 2</strong>:</p>
<p>输入: “()[]{}”</p>
<p>输出: true</p>
<p><strong>示例 3</strong>:</p>
<p>输入: “(]”</p>
<p>输出: false</p>
<p><strong>示例 4</strong>:</p>
<p>输入: “([)]”</p>
<p>输出: false</p>
<p><strong>示例 5</strong>:</p>
<p>输入: “{[]}”</p>
<p>输出: true</p>
<p>执行用时 :40 ms, 在所有 python3 提交中击败了91.98%的用户</p>
<p>内存消耗 :13.7 MB, 在所有 python3 提交中击败了5.51%的用户</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span>(len(stack) &lt;= <span class="number">0</span>):</span><br><span class="line">                stack.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            last = stack.pop()</span><br><span class="line">            <span class="comment"># 配对成功</span></span><br><span class="line">            <span class="keyword">if</span> (last == <span class="string">'('</span> <span class="keyword">and</span> i == <span class="string">')'</span> <span class="keyword">or</span></span><br><span class="line">                last == <span class="string">'['</span> <span class="keyword">and</span> i == <span class="string">']'</span> <span class="keyword">or</span></span><br><span class="line">                last == <span class="string">'&#123;'</span> <span class="keyword">and</span> i == <span class="string">'&#125;'</span>):</span><br><span class="line">                    print(last, <span class="string">" and "</span>, i, <span class="string">"success!"</span>)</span><br><span class="line">            <span class="comment"># 配对上一个符号和当前符号一次入栈</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(last)</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len(stack) &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">str_test = <span class="string">"([)]"</span></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.isValid(str_test))</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例</strong>：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p>
<p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            cur.next = l1</span><br><span class="line">        <span class="keyword">elif</span> l2:</span><br><span class="line">            cur.next = l2</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">l1.next = ListNode(<span class="number">2</span>)</span><br><span class="line">l1_next = l1.next</span><br><span class="line">l1_next.next = ListNode(<span class="number">4</span>)</span><br><span class="line">l2 = ListNode(<span class="number">1</span>)</span><br><span class="line">l2.next = ListNode(<span class="number">3</span>)</span><br><span class="line">l2_next = l2.next</span><br><span class="line">l2_next.next = ListNode(<span class="number">4</span>)</span><br><span class="line">ret = Solution().mergeTwoLists(l1, l2)</span><br><span class="line"><span class="keyword">while</span> ret:</span><br><span class="line">    print(ret.val)</span><br><span class="line">    ret = ret.next</span><br></pre></td></tr></table></figure>

<h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1</strong>:</p>
<p>给定数组 nums = [1,1,2],</p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 2</strong>:</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明</strong>:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="keyword">if</span> size &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> size</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        tmp = i</span><br><span class="line">        <span class="keyword">while</span> i &lt; size:</span><br><span class="line">            <span class="comment"># 如果前后两数字相等，则tmp存储当前位置，</span></span><br><span class="line">            <span class="comment"># i向后走一步继续寻找不同数字的位置</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[tmp] = nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                tmp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">ret = Solution().removeDuplicates(nums)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1</strong>:</p>
<p>给定 nums = [3,2,2,3], val = 3,</p>
<p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 2</strong>:</p>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>注意这五个元素可为任意顺序。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明</strong>:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: [int], val: int)</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="comment"># 这道题与上一题思路相似</span></span><br><span class="line">        <span class="comment"># 都是用双指针</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; size:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[cur] = nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ret = Solution().removeElement(s, <span class="number">3</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="53-最大子序和-动态规划"><a href="#53-最大子序和-动态规划" class="headerlink" title="53. 最大子序和-动态规划"></a>53. 最大子序和-动态规划</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例</strong>:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p>
<p>输出: 6</p>
<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> max(nums) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        local_max = <span class="number">0</span></span><br><span class="line">        global_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            local_max = max(<span class="number">0</span>, local_max+num)</span><br><span class="line">            global_max = max(local_max, global_max)</span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure>

<h3 id="55-跳跃游戏-贪婪算法"><a href="#55-跳跃游戏-贪婪算法" class="headerlink" title="55.跳跃游戏-贪婪算法"></a>55.跳跃游戏-贪婪算法</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [2,3,1,1,4]</p>
<p>输出: true</p>
<p>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [3,2,1,0,4]</p>
<p>输出: false</p>
<p>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>思路：从后往前走，看start所在位置+start所在位置可走步数能否大于end所在位置</p>
<p>   若大于，则说明start可以到达end位置，则end位置可往前移</p>
<p>   最终若end到达0点，则说明可能够到达最后一个位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从后往前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: [int])</span> -&gt; bool:</span></span><br><span class="line">        end = len(nums) - <span class="number">1</span></span><br><span class="line">        start = len(nums) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> start &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[start] + start &gt;= end:</span><br><span class="line">                end = start</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> end &lt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">ret = s.canJump(nums)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="62-不同路径-动态规划"><a href="#62-不同路径-动态规划" class="headerlink" title="62. 不同路径-动态规划"></a>62. 不同路径-动态规划</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: m = 3, n = 2</p>
<p>输出: 3</p>
<p>解释:</p>
<p>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li><p>向右 -&gt; 向右 -&gt; 向下</p>
</li>
<li><p>向右 -&gt; 向下 -&gt; 向右</p>
</li>
<li><p>向下 -&gt; 向右 -&gt; 向右</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*n] + [[<span class="number">1</span>]+[<span class="number">0</span>] * (n<span class="number">-1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().uniquePaths(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="63-不同路径II"><a href="#63-不同路径II" class="headerlink" title="63.不同路径II"></a>63.不同路径II</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p><strong>示例 1</strong>:</p>
<p>输入:</p>
<p>[ [0,0,0],</p>
<p> [0,1,0],</p>
<p> [0,0,0]]</p>
<p>输出: 2</p>
<p>解释:</p>
<p>3x3 网格的正中间有一个障碍物。</p>
<p>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li><p>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</p>
</li>
<li><p>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p>
</li>
</ol>
<p><strong>思路</strong>: 将障碍位置可以到达的方法设为0即可(该方法速度过慢)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># m 行 ,n 列</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j] + obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>优化思路</strong>:将0,0位置的赋值，以及第一行和第一列的赋值提出来,避免双层循环内大量if判断降低运行速度.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># m 行 ,n 列</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将第一行数据赋值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][j] = <span class="number">1</span> <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][j<span class="number">-1</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将第一列数据赋值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[i<span class="number">-1</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j] + obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">ret = Solution().uniquePathsWithObstacles(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p><strong>示例</strong>:</p>
<p>输入:</p>
<p>[ [1,3,1],</p>
<p> [1,5,1],</p>
<p> [4,2,1]]</p>
<p>输出: 7</p>
<p>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        m = len(grid)     <span class="comment"># 行</span></span><br><span class="line">        n = len(grid[<span class="number">0</span>])  <span class="comment"># 列</span></span><br><span class="line">        <span class="comment"># 先把第一列算出来</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            grid[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + grid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再把第一行算出来</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            grid[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + grid[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 比较该位置上方或左方数字，将较小值加给该位置</span></span><br><span class="line">                <span class="comment"># if grid[i-1][j] &lt; grid[i][j-1]:</span></span><br><span class="line">                <span class="comment">#     num = grid[i-1][j]</span></span><br><span class="line">                <span class="comment"># else:</span></span><br><span class="line">                <span class="comment">#     num = grid[i][j-1]</span></span><br><span class="line">                num = grid[i<span class="number">-1</span>][j] <span class="keyword">if</span> grid[i<span class="number">-1</span>][j] &lt; grid[i][j<span class="number">-1</span>] <span class="keyword">else</span> grid[i][j<span class="number">-1</span>]</span><br><span class="line">                grid[i][j] += num</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">     [<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line">     [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line">ret = Solution().minPathSum(s)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>示例 1</strong>：</p>
<p>输入： 2</p>
<p>输出： 2</p>
<p>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li><p>1 阶 + 1 阶</p>
</li>
<li><p>2 阶</p>
</li>
</ol>
<p><strong>示例 2</strong>：</p>
<p>输入： 3</p>
<p>输出： 3</p>
<p>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li><p>1 阶 + 1 阶 + 1 阶</p>
</li>
<li><p>1 阶 + 2 阶</p>
</li>
<li><p>2 阶 + 1 阶</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        climbNums = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        climbNums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        climbNums[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(climbNums)):</span><br><span class="line">            climbNums[i] = climbNums[i<span class="number">-2</span>] + climbNums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> climbNums[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().climbStairs(<span class="number">6</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="71-简化路径-栈"><a href="#71-简化路径-栈" class="headerlink" title="71.简化路径-栈"></a>71.简化路径-栈</h3><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p><strong>示例 1</strong>：</p>
<p>输入：”/home/“</p>
<p>输出：”/home”</p>
<p>解释：注意，最后一个目录名后面没有斜杠。</p>
<p><strong>示例 2</strong>：</p>
<p>输入：”/../“</p>
<p>输出：”/“</p>
<p>解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p>
<p><strong>示例 3</strong>：</p>
<p>输入：”/home//foo/“</p>
<p>输出：”/home/foo”</p>
<p>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</p>
<p><strong>示例 4</strong>：</p>
<p>输入：”/a/./b/../../c/“</p>
<p>输出：”/c”</p>
<p><strong>示例 5</strong>：</p>
<p>输入：”/a/../../b/../c//.//“</p>
<p>输出：”/c”</p>
<p><strong>示例 6</strong>：</p>
<p>输入：”/a//b////c/d//././/..”</p>
<p>输出：”/a/b/c”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        path_list = path.split(<span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path_list:</span><br><span class="line">            <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> i == <span class="string">".."</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> i != <span class="string">'.'</span> <span class="keyword">and</span> i != <span class="string">''</span> <span class="keyword">and</span> i != <span class="string">'..'</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.simplifyPath(<span class="string">"/../"</span>))</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h3><p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出: [1,3,2]</p>
<p>执行用时 :44 ms, 在所有 python3 提交中击败了75.75%的用户</p>
<p>内存消耗 :13.7 MB, 在所有 python3 提交中击败了5.32%的用户</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ret, stack = [], []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.val <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                ret.append(node.val)</span><br><span class="line">            root = node.right</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = TreeNode(<span class="number">1</span>)</span><br><span class="line">t.left = <span class="literal">None</span></span><br><span class="line">t.right = TreeNode(<span class="number">2</span>)</span><br><span class="line">t2 = t.right</span><br><span class="line">t2.left = TreeNode(<span class="number">3</span>)</span><br><span class="line">t2.right = TreeNode(<span class="literal">None</span>)</span><br><span class="line">t3 = t2.left</span><br><span class="line">t3.left = <span class="literal">None</span></span><br><span class="line">t3.right = <span class="literal">None</span></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.inorderTraversal(t)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="122-买卖股票的最佳时机-II-贪婪算法"><a href="#122-买卖股票的最佳时机-II-贪婪算法" class="headerlink" title="122.买卖股票的最佳时机 II-贪婪算法"></a>122.买卖股票的最佳时机 II-贪婪算法</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [7,1,5,3,6,4]</p>
<p>输出: 7</p>
<p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p>
<p>   随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [1,2,3,4,5]</p>
<p>输出: 4</p>
<p>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p>
<p>   注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</p>
<p>   因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: [7,6,4,3,1]</p>
<p>输出: 0</p>
<p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>思路：所有上涨交易日都买卖，所有下降交易日都不买卖</p>
<p>   “等价于每天都买卖”，把可能跨越多天的买卖都化解成相邻两天的买卖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: [int])</span> -&gt; int:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            tmp = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">                sum += tmp</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">price = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ret = s.maxProfit(price)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="134-加油站-贪婪算法"><a href="#134-加油站-贪婪算法" class="headerlink" title="134.加油站-贪婪算法"></a>134.加油站-贪婪算法</h3><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明: </p>
<p>如果题目有解，该答案即为唯一答案。</p>
<p>输入数组均为非空数组，且长度相同。</p>
<p>输入数组中的元素均为非负数。</p>
<p><strong>示例 1</strong>:</p>
<p>输入:</p>
<p>gas = [1,2,3,4,5]</p>
<p>cost = [3,4,5,1,2]</p>
<p>输出: 3</p>
<p>解释:</p>
<p>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</p>
<p>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</p>
<p>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</p>
<p>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</p>
<p>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</p>
<p>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</p>
<p>因此，3 可为起始索引。</p>
<p><strong>示例 2</strong>:</p>
<p>输入:</p>
<p>gas = [2,3,4]</p>
<p>cost = [3,4,3]</p>
<p>输出: -1</p>
<p>解释:</p>
<p>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</p>
<p>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</p>
<p>开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</p>
<p>开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</p>
<p>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</p>
<p>因此，无论怎样，你都不可能绕环路行驶一周。</p>
<p>这道题还有些不清楚</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        location = <span class="number">0</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果每个站点加的油总量和小于消耗的总油量，则肯定环绕不了一周</span></span><br><span class="line">        <span class="keyword">if</span> sum(gas) &lt; sum(cost):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            total_sum += gas[index] - cost[index]</span><br><span class="line">            <span class="keyword">if</span> total_sum &lt; <span class="number">0</span>:</span><br><span class="line">                location = index+<span class="number">1</span></span><br><span class="line">                total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = Solution().canCompleteCircuit([<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>], [<span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="215-数组中的第K个最大元素-堆"><a href="#215-数组中的第K个最大元素-堆" class="headerlink" title="215.数组中的第K个最大元素-堆"></a>215.数组中的第K个最大元素-堆</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [3,2,1,5,6,4] 和 k = 2</p>
<p>输出: 5</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</p>
<p>输出: 4</p>
<p>说明:</p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: [int], k: int)</span> -&gt; int:</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[:k]:</span><br><span class="line">            heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">                heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.findKthLargest(nums, <span class="number">2</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="264-丑数II-堆"><a href="#264-丑数II-堆" class="headerlink" title="264.丑数II-堆"></a>264.丑数II-堆</h3><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p><strong>示例</strong>:</p>
<p>输入: n = 10</p>
<p>输出: 12</p>
<p>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
<p><strong>说明</strong>: </p>
<p>1 是丑数。</p>
<p>n 不超过1690。</p>
<p>因为丑数是2, 3, 5的倍数，我们不断把它们的倍数压入栈中，再按顺序弹出！</p>
<p>时间复杂度：nlogn</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heap = []</span><br><span class="line">        heapq.heappush(heap, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> ret == heap[<span class="number">0</span>]:</span><br><span class="line">                ret = heapq.heappop(heap)</span><br><span class="line">            a, b, c = ret*<span class="number">2</span>, ret*<span class="number">3</span>, ret*<span class="number">5</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c]:</span><br><span class="line">                heapq.heappush(heap, i)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.nthUglyNumber(<span class="number">9</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="313-超级丑数-堆"><a href="#313-超级丑数-堆" class="headerlink" title="313.超级丑数-堆"></a>313.超级丑数-堆</h3><p>编写一段程序来查找第 n 个超级丑数。</p>
<p>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</p>
<p><strong>示例:</strong></p>
<p>输入: n = 12, primes = [2,7,13,19]</p>
<p>输出: 32</p>
<p>解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</p>
<p><strong>说明</strong>:</p>
<p>1 是任何给定 primes 的超级丑数。</p>
<p> 给定 primes 中的数字以升序排列。</p>
<p>0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。</p>
<p>第 n 个超级丑数确保在 32 位有符整数范围内。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span><span class="params">(self, n: int, primes: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heap = []</span><br><span class="line">        heapq.heappush(heap, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> ret == heap[<span class="number">0</span>]:</span><br><span class="line">                ret = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> primes:</span><br><span class="line">                heapq.heappush(heap, ret*i)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">primes = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">19</span>]</span><br><span class="line">ret = s.nthSuperUglyNumber(<span class="number">12</span>, primes)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="347-前-K-个高频元素-堆"><a href="#347-前-K-个高频元素-堆" class="headerlink" title="347.前 K 个高频元素-堆"></a>347.前 K 个高频元素-堆</h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2</p>
<p>输出: [1,2]</p>
<p><strong>示例 2</strong>:</p>
<p>输入: nums = [1], k = 1</p>
<p>输出: [1]</p>
<p><strong>说明</strong>：</p>
<p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</p>
<p>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自己的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        num_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> num_dict:</span><br><span class="line">                num_dict[i] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            num_dict[i] += <span class="number">1</span></span><br><span class="line">        ret = sorted(num_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        ret = ret[:k]</span><br><span class="line">        ret = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> ret]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">        </span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ret = s.topKFrequent(nums, <span class="number">2</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = collections.Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ret = s.topKFrequent(nums, <span class="number">2</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="376-摆动序列-贪婪算法"><a href="#376-摆动序列-贪婪算法" class="headerlink" title="376.摆动序列-贪婪算法"></a>376.摆动序列-贪婪算法</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如, [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。</p>
<p>相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [1,7,4,9,2,5]</p>
<p>输出: 6</p>
<p>解释: 整个序列均为摆动序列。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [1,17,5,10,13,15,10,5,16,8]</p>
<p>输出: 7</p>
<p>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</p>
<p><strong>示例 3</strong>:</p>
<p>输入: [1,2,3,4,5,6,7,8,9]</p>
<p>输出: 2</p>
<p>进阶:</p>
<p>你能否用 O(n) 时间复杂度完成此题?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        max_len_list = [nums[<span class="number">0</span>]]</span><br><span class="line">        UP = <span class="literal">False</span></span><br><span class="line">        DOWN = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> UP <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                UP = <span class="literal">True</span></span><br><span class="line">                DOWN = <span class="literal">False</span></span><br><span class="line">                max_len_list.append(nums[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> UP <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 持续上升，替换为最大值</span></span><br><span class="line">                max_len_list[<span class="number">-1</span>] = nums[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> DOWN <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                DOWN = <span class="literal">True</span></span><br><span class="line">                UP = <span class="literal">False</span></span><br><span class="line">                max_len_list.append(nums[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> DOWN <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] - nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                max_len_list[<span class="number">-1</span>] = nums[i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> len(max_len_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">ret = Solution().wiggleMaxLength(nums)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="392-判断子序列-贪婪算法"><a href="#392-判断子序列-贪婪算法" class="headerlink" title="392.判断子序列-贪婪算法"></a>392.判断子序列-贪婪算法</h3><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p><strong>示例 1</strong>:</p>
<p>s = “abc”, t = “ahbgdc”</p>
<p>返回 true.</p>
<p><strong>示例 2</strong>:</p>
<p>s = “axc”, t = “ahbgdc”</p>
<p>返回 false.</p>
<p>后续挑战 :</p>
<p>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] == i:</span><br><span class="line">                s = s[<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> len(s) &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.isSubsequence(<span class="string">""</span>, <span class="string">"ahbgdc"</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="402-移掉K位数字-贪婪算法"><a href="#402-移掉K位数字-贪婪算法" class="headerlink" title="402.移掉K位数字-贪婪算法"></a>402.移掉K位数字-贪婪算法</h3><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<p>num 的长度小于 10002 且 ≥ k。</p>
<p>num 不会包含任何前导零。</p>
<p><strong>示例 1</strong> :</p>
<p>输入: num = “1432219”, k = 3</p>
<p>输出: “1219”</p>
<p>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p>
<p><strong>示例 2</strong> :</p>
<p>输入: num = “10200”, k = 1</p>
<p>输出: “200”</p>
<p>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<p><strong>示例 3</strong> :</p>
<p>输入: num = “10”, k = 2</p>
<p>输出: “0”</p>
<p>解释: 从原数字移除所有的数字，剩余为空就是0。</p>
<p>利用桟维持一个递增的序列，也就是说将字符串中字符依次入栈，</p>
<p>如果当前字符比栈顶元素小，并且还可以继续删除元素，那么就将栈顶元素移掉，且继续向下一个栈顶元素比较，尽量维持序列递增，也可以算是一个贪心思想。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(num) == k:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        stack = [num[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; num[i] <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(num[i])</span><br><span class="line">        <span class="comment"># k &gt; 0说明剩余数字为全部相同或者递增如：11111或12345</span></span><br><span class="line">        <span class="comment"># 将后k个删除即可</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            stack = stack[:-k]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> stack[<span class="number">0</span>] == <span class="string">'0'</span> <span class="keyword">and</span> len(stack) &gt; <span class="number">1</span>:</span><br><span class="line">                stack = stack[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="string">"1234560"</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">ret = Solution().removeKdigits(num, <span class="number">6</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="455-分发饼干-贪婪算法"><a href="#455-分发饼干-贪婪算法" class="headerlink" title="455.分发饼干-贪婪算法"></a>455.分发饼干-贪婪算法</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，</p>
<p>这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，</p>
<p>这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>注意：</p>
<p>你可以假设胃口值为正。</p>
<p>一个小朋友最多只能拥有一块饼干。</p>
<p><strong>示例 1</strong>:</p>
<p>输入: [1,2,3], [1,1]</p>
<p>输出: 1</p>
<p>解释:</p>
<p>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</p>
<p>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</p>
<p>所以你应该输出1。</p>
<p><strong>示例 2</strong>:</p>
<p>输入: [1,2], [1,2,3]</p>
<p>输出: 2</p>
<p>解释:</p>
<p>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</p>
<p>你拥有的饼干数量和尺寸都足以让所有孩子满足。</p>
<p>所以你应该输出2.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span><span class="params">(self, g: [int], s: [int])</span> -&gt; int:</span></span><br><span class="line">        child_list = sorted(g)  <span class="comment"># 小朋友</span></span><br><span class="line">        cookie_list = sorted(s)  <span class="comment"># 小饼干</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        child_index = <span class="number">0</span></span><br><span class="line">        cookie_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> child_index &lt; len(child_list) <span class="keyword">and</span> cookie_index &lt; len(cookie_list):</span><br><span class="line">            <span class="keyword">if</span> cookie_list[cookie_index] &gt;= child_list[child_index]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">                child_index += <span class="number">1</span></span><br><span class="line">            cookie_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">ret = s.findContentChildren([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="703-数据流中的第K大元素-堆"><a href="#703-数据流中的第K大元素-堆" class="headerlink" title="703.数据流中的第K大元素-堆"></a>703.数据流中的第K大元素-堆</h3><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p>
<p>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>];</span><br><span class="line">KthLargest kthLargest = <span class="keyword">new</span> KthLargest(<span class="number">3</span>, arr);</span><br><span class="line">kthLargest.add(<span class="number">3</span>);  <span class="comment">// returns 4</span></span><br><span class="line">kthLargest.add(<span class="number">5</span>);  <span class="comment">// returns 5</span></span><br><span class="line">kthLargest.add(<span class="number">10</span>); <span class="comment">// returns 5</span></span><br><span class="line">kthLargest.add(<span class="number">9</span>);  <span class="comment">// returns 8</span></span><br><span class="line">kthLargest.add(<span class="number">4</span>);  <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure>

<p>执行用时 :120 ms, 在所有 python3 提交中击败了95.49%的用户</p>
<p>内存消耗 :17.4 MB, 在所有 python3 提交中击败了5.63%的用户</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int, nums: [int])</span>:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums = nums[:k]</span><br><span class="line">        heapq.heapify(self.nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> i &gt; self.nums[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(self.nums)</span><br><span class="line">                heapq.heappush(self.nums, i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="keyword">if</span> len(self.nums) &lt; self.k:</span><br><span class="line">            heapq.heappush(self.nums, val)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.nums[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappop(self.nums)</span><br><span class="line">            heapq.heappush(self.nums, val)</span><br><span class="line">        <span class="keyword">return</span> self.nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">s = KthLargest(k, arr)</span><br><span class="line">ret = s.add(<span class="number">3</span>)</span><br><span class="line">print(ret)  <span class="comment"># 4</span></span><br><span class="line">ret = s.add(<span class="number">5</span>)</span><br><span class="line">print(ret)  <span class="comment"># 5</span></span><br><span class="line">ret = s.add(<span class="number">10</span>)</span><br><span class="line">print(ret)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<h3 id="1021-删除最外层的括号-栈"><a href="#1021-删除最外层的括号-栈" class="headerlink" title="1021.删除最外层的括号-栈"></a>1021.删除最外层的括号-栈</h3><p>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
<p><strong>示例 1</strong>：</p>
<p>输入：”(()())(())”</p>
<p>输出：”()()()”</p>
<p>解释：</p>
<p>输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，</p>
<p>删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。</p>
<p><strong>示例 2</strong>：</p>
<p>输入：”(()())(())(()(()))”</p>
<p>输出：”()()()()(())”</p>
<p>解释：</p>
<p>输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，</p>
<p>删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。</p>
<p><strong>示例 3</strong>：</p>
<p>输入：”()()”</p>
<p>输出：””</p>
<p>解释：</p>
<p>输入字符串为 “()()”，原语化分解得到 “()” + “()”，</p>
<p>删除每个部分中的最外层括号后得到 “” + “” = “”。</p>
<p><strong>提示</strong>：</p>
<p>S.length &lt;= 10000</p>
<p>S[i] 为 “(“ 或 “)”</p>
<p>S 是一个有效括号字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeOuterParentheses</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        ret_str = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">if</span>(len(stack) &gt;= <span class="number">1</span>):</span><br><span class="line">                    ret_str += i</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># i == ')'</span></span><br><span class="line">                <span class="keyword">if</span>(len(stack) &gt; <span class="number">1</span>):</span><br><span class="line">                    ret_str += i</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> ret_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">s_test = <span class="string">"(()())(())(()(()))"</span></span><br><span class="line">print(s.removeOuterParentheses(s_test))</span><br></pre></td></tr></table></figure>

<h3 id="1047-删除字符串中的所有相邻重复项-栈"><a href="#1047-删除字符串中的所有相邻重复项-栈" class="headerlink" title="1047.删除字符串中的所有相邻重复项-栈"></a>1047.删除字符串中的所有相邻重复项-栈</h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例</strong>：</p>
<p>输入：”abbaca”</p>
<p>输出：”ca”</p>
<p>解释：</p>
<p>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p>
<p><strong>提示</strong>：</p>
<p>1 &lt;= S.length &lt;= 20000</p>
<p>S 仅由小写英文字母组成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == i:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        ret_str = <span class="string">''</span>.join(stack)</span><br><span class="line">        <span class="keyword">return</span> ret_str</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.removeDuplicates(<span class="string">"abbaca"</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2019/10/22/hexo/</url>
    <content><![CDATA[<h1 id="通过Hexo建立个人博客站点"><a href="#通过Hexo建立个人博客站点" class="headerlink" title="通过Hexo建立个人博客站点"></a>通过<em>Hexo</em>建立个人博客站点</h1><h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p><img src="/2019/10/22/hexo/start.png" alt></p>
<a id="more"></a>
<h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>
<ul>
<li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.6，建议使用 Node.js 10.0 及以上版本)</li>
<li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li>
</ul>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="1-git基础安装"><a href="#1-git基础安装" class="headerlink" title="1.git基础安装"></a>1.git基础安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install git gcc gcc-c++ curl wget</span><br></pre></td></tr></table></figure>

<p>为什么要首先要安装 git？</p>
<p>因为 Hexo 开源且基于 Node.js 环境，所以大量主题和设置需要通过 git 完成。 </p>
<h4 id="2-安装-Node-js"><a href="#2-安装-Node-js" class="headerlink" title="2.安装 Node.js"></a>2.安装 Node.js</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/cnpm/nvm.git</span><br><span class="line">cd nvm</span><br><span class="line">sh ./install.sh</span><br><span class="line">source $HOME/nvm/nvm.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm install v0.10.32 &amp;&amp; nvm use 0.10</span><br></pre></td></tr></table></figure>

<h4 id="踩坑！！"><a href="#踩坑！！" class="headerlink" title="踩坑！！"></a>踩坑！！</h4><p>nodejs版本过低，会导后面的安装步骤报错。</p>
<p>解决办法：升级nodejs，建议使用 <strong>Node.js 10.0 及以上</strong>版本 。</p>
<p>升级nodejs教程如下：</p>
<p><a href="https://segmentfault.com/a/1190000015302680" target="_blank" rel="noopener">在centos7安装nodejs并升级nodejs到最新版本</a> </p>
<h4 id="3-部署Hexo"><a href="#3-部署Hexo" class="headerlink" title="3.部署Hexo"></a>3.部署Hexo</h4><p><strong>安装Hexo</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo --save</span><br></pre></td></tr></table></figure>

<p><strong>初始化Hexo</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /home/wwwroot &amp;&amp; hexo init /home/wwwroot</span><br></pre></td></tr></table></figure>

<h4 id="4-列举几个常用配置"><a href="#4-列举几个常用配置" class="headerlink" title="4.列举几个常用配置"></a>4.列举几个常用配置</h4><p>配置文件_config.yml就在上一步初始化所填写的路径内。</p>
<p><img src="/2019/10/22/hexo/config.png" alt></p>
<p><img src="/2019/10/22/hexo/configfile.png" alt></p>
<p>时区列表可参考该网页：<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">时区列表</a></p>
<h4 id="坑！！注意！！！"><a href="#坑！！注意！！！" class="headerlink" title="坑！！注意！！！"></a>坑！！注意！！！</h4><p>在填写配置表时，<strong>’ : ‘</strong> 后面要紧跟一个空格再写具体配置，否则在启动Hexo的时候会报错！</p>
<h4 id="5-启动Hexo"><a href="#5-启动Hexo" class="headerlink" title="5.启动Hexo"></a>5.启动Hexo</h4><p>完成上面简单的几部，我们的私人博客已经建好了。下面启动查看。启动后我们可以访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看，发现已经有一篇默认的博客。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server 或 hexo s</span><br></pre></td></tr></table></figure>

<p><img src="/2019/10/22/hexo/default_html.png" alt></p>
<p><strong>太丑了怎么办！</strong></p>
<p><img src="/2019/10/22/hexo/ugly.jpeg" alt></p>
<p><strong>别急，Hexo拥有许多强大特性的,现代、简洁的主题！</strong></p>
<p><img src="/2019/10/22/hexo/thems.png" alt></p>
<p>我这里找了一个帖子，有楼主收集了很多好看的主题，并附有github下载链接。帖子链接：<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">Hexo主题</a></p>
<p><strong>如何使用主题？</strong></p>
<p>将主题下载到安装路径下的themes目录里，我这里是 <code>wwwroot/themes</code>。</p>
<p><img src="/2019/10/22/hexo/wwwroot_themes.png" alt></p>
<p>下载好主题后需在配置表_config.yml里修改主题。</p>
<p><img src="/2019/10/22/hexo/themes_config.png" alt></p>
<p><strong>替换后效果：</strong></p>
<p><img src="/2019/10/22/hexo/myblog.png" alt></p>
<h3 id="好了，花里胡哨的东西讲完了，我们的网页还是在本地跑，这可太low了！"><a href="#好了，花里胡哨的东西讲完了，我们的网页还是在本地跑，这可太low了！" class="headerlink" title="好了，花里胡哨的东西讲完了，我们的网页还是在本地跑，这可太low了！"></a>好了，花里胡哨的东西讲完了，我们的网页还是在本地跑，这可太low了！</h3><p>如果你有云服务器，你把这一切部署在你的服务器上，别人就可以访问了。但是，如果你<strong>没钱买服务器</strong>，Hexo也为你们考虑到了！</p>
<p><img src="/2019/10/22/hexo/nomoney.jpg" alt></p>
<h3 id="我们可以把搭建的Hexo关联Git（GitHub与Gitlab都可以，此处只列举如何关联GitHub）"><a href="#我们可以把搭建的Hexo关联Git（GitHub与Gitlab都可以，此处只列举如何关联GitHub）" class="headerlink" title="我们可以把搭建的Hexo关联Git（GitHub与Gitlab都可以，此处只列举如何关联GitHub）"></a>我们可以把搭建的Hexo关联Git（GitHub与Gitlab都可以，此处只列举如何关联GitHub）</h3><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>登录你的Github帐号，新建仓库，命名为<strong>用户名.github.io</strong>固定写法，如scooola.github.io即下图中所示：</p>
<p><img src="/2019/10/22/hexo/github.png" alt>用文本编辑器打开_config.yml,打开后往下滑到最后，修改成下边的样子： </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">    type:</span> <span class="string">git</span> </span><br><span class="line"><span class="attr">    repository:</span> <span class="attr">https://github.com/scooola/scooola.github.io.git</span> </span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>在blog文件夹目录下执行生成静态页面命令： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo generate 或者：hexo g</span></span><br></pre></td></tr></table></figure>

<p>此时若出现如下报错： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR Local hexo not found in ~/blog</span><br><span class="line">ERROR Try runing: 'npm install hexo --save'</span><br><span class="line"></span><br><span class="line">则执行命令：npm install hexo --save</span><br><span class="line">若无报错，自行忽略此步骤。</span><br></pre></td></tr></table></figure>

<p>再执行配置命令： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy 或者：hexo d</span></span><br></pre></td></tr></table></figure>

<p><strong>注意坑</strong>：</p>
<p>若执行命令hexo deploy 仍然报错：无法连接git或找不到git，则执行如下命令来安装<strong>hexo-deployer-git</strong>： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure>

<p>安装完毕后，再次执行hexo generate和hexo deploy命令。 若你未关联Github，则执行hexo deploy 命令时终端会提示你输入Github的用户名和密码，即 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Username for 'https://github.com':</span><br><span class="line">Password for 'https://github.com':</span><br></pre></td></tr></table></figure>

<p>hexo deploy 命令执行成功后，浏览器中打开网址<a href="http://scooola.github.io">http://scooola.github.io</a>（将scooola换成你的用户名）能看到和打开<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 时一样的页面。</p>
<h3 id="发布新文章"><a href="#发布新文章" class="headerlink" title="发布新文章"></a>发布新文章</h3><p>输入 hexo new 文章名.md，即可在wwwroot/source/_posts目录下看的新生成的文件。</p>
<p><img src="/2019/10/22/hexo/new_blog.png" alt></p>
<p>随后生成静态网页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate 或 hexo g</span><br></pre></td></tr></table></figure>

<p>发布网站（推送到github）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy 或 hexo d</span><br></pre></td></tr></table></figure>

<p>输入完上述命令后，我们就可以在我们的网页上看到新发布的博客了！</p>
<h4 id="可是没有图片的博客也太过于枯燥了，我们需要修改一下配置才可以发布带有图片的博客"><a href="#可是没有图片的博客也太过于枯燥了，我们需要修改一下配置才可以发布带有图片的博客" class="headerlink" title="可是没有图片的博客也太过于枯燥了，我们需要修改一下配置才可以发布带有图片的博客"></a>可是没有图片的博客也太过于枯燥了，我们需要修改一下配置才可以发布带有图片的博客</h4><p>下面我们修改配置<strong>post_asset_folder: true</strong></p>
<p><img src="/2019/10/22/hexo/poster_asset_folder.png" alt></p>
<p>我们再次输入创建博客的命令 hexo new 文件名，发现在source/_posts/目录下创建了一个文件以及同名的文件夹。</p>
<p><img src="/2019/10/22/hexo/blog_with_photo.png" alt></p>
<p>之后，需要安装一个插件，在hexo的安装目录下运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，我们可以把图片放入刚才创建的文件blog-可加入图片内，在md文件中如下格式引入即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](图片名.jpg)</span><br></pre></td></tr></table></figure>

<p>引入图片后的效果如下图：</p>
<p><img src="/2019/10/22/hexo/photo_in_blog.png" alt></p>
<h3 id="关于md文件插入本地图片在GitHub-Pages无法显示的问题说明"><a href="#关于md文件插入本地图片在GitHub-Pages无法显示的问题说明" class="headerlink" title="关于md文件插入本地图片在GitHub Pages无法显示的问题说明"></a>关于md文件插入本地图片在GitHub Pages无法显示的问题说明</h3><p>由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径为%d/xxx/xxx需要对其做兼容处理。通过判断当前版本是否等于3的版本做不同的路径分割。因此，这里提供一个已经修复这个bug的插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>之后重新编译发布即可。然后刷新浏览器即可！</p>
<h4 id="hexo博客迁移"><a href="#hexo博客迁移" class="headerlink" title="hexo博客迁移"></a>hexo博客迁移</h4><h2 id="备份原文件"><a href="#备份原文件" class="headerlink" title="备份原文件"></a>备份原文件</h2><p>需要转移的文件有：</p>
<table>
<thead>
<tr>
<th align="left">文件(夹)</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">scaffolds/</td>
<td align="left">博客文章模板</td>
</tr>
<tr>
<td align="left">source/</td>
<td align="left">所有的博客文章</td>
</tr>
<tr>
<td align="left">themes/</td>
<td align="left">网站主题</td>
</tr>
<tr>
<td align="left">.gitignore</td>
<td align="left">push时需忽略的文件</td>
</tr>
<tr>
<td align="left">_config.yml</td>
<td align="left">站点配置文件</td>
</tr>
<tr>
<td align="left">package.json</td>
<td align="left">依赖包的名称和版本号</td>
</tr>
</tbody></table>
<p>由于配置文件和主题文件需要经常更改，采用github创建博客分支的方式进行备份。</p>
<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>克隆github上上生成的静态文件到hexo文件夹中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/yourname/xxxx.github.io.git hexo</span><br></pre></td></tr></table></figure>

<p>克隆后将除.git文件外其他所有文件删除。主要是为了得到版本管理文件夹.git。</p>
<p><strong>.git文件为隐藏文件，可直接将可见文件全部删除</strong></p>
<p>将备份的原文件复制到此文件夹。若文件夹是从github克隆，则需要删除主题文件中的版本控制文件夹,以next主题为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf thems/next/.git*</span></span><br></pre></td></tr></table></figure>

<p>创建名为hexo的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b hexo</span></span><br></pre></td></tr></table></figure>

<p>保存所有文件到暂存区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add --all</span></span><br></pre></td></tr></table></figure>

<p>提交变更</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"hexo服务备份"</span></span></span><br></pre></td></tr></table></figure>

<p><strong>迁移</strong></p>
<p>以后在其他电脑上写博客，直接将分支克隆下来。再使用npm install安装依赖。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> -b hexo https://github.com/yourname/xxx.github.io.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure>

<h3 id="hexo生成文章目录-该方法仅支持默认主题"><a href="#hexo生成文章目录-该方法仅支持默认主题" class="headerlink" title="hexo生成文章目录-该方法仅支持默认主题"></a>hexo生成文章目录-该方法仅支持默认主题</h3><p>Hexo博客系统的核心支持生成目录（Table of Contents），但其默认的主题Landscape并不支持目录的显示。我们只需对Landscape的主题文件稍作修改并添加一点目录的CSS就可以在文章前面显示友好的目录了。</p>
<h4 id="修改Landscape主题的ejs文件"><a href="#修改Landscape主题的ejs文件" class="headerlink" title="修改Landscape主题的ejs文件"></a>修改Landscape主题的ejs文件</h4><p>我们首先要编辑文章显示页面的模板，也就是<code>themes/landscape/layout/_partial/article.ejs</code>文件。为了将目录生成在正文之前，我们首先在这个文件中找到<code>&lt;%- post.content %&gt;</code>，并在<strong>这一行之前</strong>加入如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span> <span class="selector-tag">Table</span> <span class="selector-tag">of</span> <span class="selector-tag">Contents</span> <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;</span><br><span class="line">  &lt;div id="toc" class="toc-article"&gt;</span><br><span class="line">    &lt;strong class="toc-title"&gt;文章目录&lt;/strong&gt;</span><br><span class="line">    &lt;%<span class="selector-tag">-</span> <span class="selector-tag">toc</span>(<span class="selector-tag">post</span><span class="selector-class">.content</span>), &#123;<span class="attribute">list_number</span>: false&#125; %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>其中list_number:false表示不显示序号，如果你想要打开可以设置为true</p>
<p>修改完这个文件之后，找一篇包含了多个子标题的文章，并在文章开头的front-matter中添加一句<code>toc: true</code>，在浏览器中访问这篇文章，应该可以看到文章的开头处已经有了带链接的目录。但是这样的目录实在太难看，我们还需要添加相应的CSS来将其指定为我们想要的样式。</p>
<p><strong>踩坑</strong>：若目录不能跳转，则可能安装了hexo-toc 这个插件导致的 ，所以卸载掉重新发布就好。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm remove hexo-toc --save</span><br></pre></td></tr></table></figure>

<h4 id="为目录编写CSS文件"><a href="#为目录编写CSS文件" class="headerlink" title="为目录编写CSS文件"></a>为目录编写CSS文件</h4><p>要指定目录的样式，我们要修改的文件是<code>themes/landscape/source/css/_partial/article.styl</code>。在文件的最后，添加如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*toc*/</span></span><br><span class="line"><span class="selector-class">.toc-article</span></span><br><span class="line">  <span class="selector-tag">background</span> <span class="selector-id">#eee</span></span><br><span class="line">  <span class="selector-tag">border</span> 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#bbb</span></span><br><span class="line">  <span class="selector-tag">border-radius</span> 10<span class="selector-tag">px</span></span><br><span class="line">  <span class="selector-tag">margin</span> 1<span class="selector-class">.5em</span> 0 0<span class="selector-class">.3em</span> 1<span class="selector-class">.5em</span></span><br><span class="line">  <span class="selector-tag">padding</span> 1<span class="selector-class">.2em</span> 1<span class="selector-tag">em</span> 0 1<span class="selector-tag">em</span></span><br><span class="line">  <span class="selector-tag">max-width</span> 28%</span><br><span class="line"><span class="selector-class">.toc-title</span></span><br><span class="line">  <span class="selector-tag">font-size</span> 120%</span><br><span class="line"><span class="selector-id">#toc</span></span><br><span class="line">  <span class="selector-tag">line-height</span> 1<span class="selector-tag">em</span></span><br><span class="line">  <span class="selector-tag">font-size</span> 0<span class="selector-class">.9em</span></span><br><span class="line">  <span class="selector-tag">float</span> <span class="selector-tag">right</span></span><br><span class="line">  <span class="selector-class">.toc</span></span><br><span class="line">    <span class="selector-tag">padding</span> 0</span><br><span class="line">    <span class="selector-tag">margin</span> 1<span class="selector-tag">em</span></span><br><span class="line">    <span class="selector-tag">line-height</span> 1<span class="selector-class">.8em</span></span><br><span class="line">    <span class="selector-tag">li</span></span><br><span class="line">      <span class="selector-tag">list-style-type</span> <span class="selector-tag">none</span></span><br><span class="line">  <span class="selector-class">.toc-child</span> </span><br><span class="line">    <span class="selector-tag">margin-left</span> 1<span class="selector-tag">em</span></span><br></pre></td></tr></table></figure>

<p>第一段的<code>toc-article</code>指定了目录整个``的背景色、边框色、倒角半径、各种间距以及最大的宽度。注意这里最好指定目录的最大宽度，我将其设为了<code>28%</code>，也就是文章正文那个框的宽度的<code>28%</code>，也可以设为一个固定的长度，比如在笔记本电脑上<code>16em</code>就是个不错的宽度，但为了能适配各种不同尺寸的屏幕，最好还是设置为百分比。如果不指定最大宽度，遇到比较长的标题时，生成的目录会非常难看。这个最大宽度的设置是我在网上其他添加目录的方法中没有见到的。</p>
<p>第二段的<code>toc-title</code>指的就是“文章目录”那四个字，这四个字要比其他字大一些，将其字号设为其他字的<code>120%</code>。</p>
<p>第三段的<code>#toc.toc</code>指定了目录列表的一些细节，将<code>font-size</code>设为<code>0.9em</code>会让目录的字比文章的字稍小一些。最后的<code>.toc-child</code>指定了二级目录的缩进量。</p>
<p>再次生成页面，应该已经可以显示比较美观的目录了。</p>
<h4 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h4><p>通常情况下我们不需要为每一篇文章都添加目录，因为大部分文章的长度还是相对较短，或者结构简单而没有添加小标题。在我的博客上，需要添加目录的长文还是相对较少的。因为我选择了默认不生成目录，而手动为需要目录的文章添加显式地标记。</p>
<p>下面我就需要编辑每一篇需要添加目录的文章，在文章开头的front-matter中加入<code>toc: true</code>。</p>
<h3 id="加入文章置顶功能"><a href="#加入文章置顶功能" class="headerlink" title="加入文章置顶功能"></a>加入文章置顶功能</h3><p>目前已经有修改后支持置顶的仓库，可以直接用以下命令安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm uninstall hexo-generator-index --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-index-pin-top --save</span></span><br></pre></td></tr></table></figure>
<p>然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo</span><br><span class="line">date: 2019-10-22 15:02:19</span><br><span class="line">tags: 实践</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p><strong>设置置顶标志</strong><br>打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到<div class="post-meta">标签下，插入如下代码：</div></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习笔记</title>
    <url>/2019/10/21/python/</url>
    <content><![CDATA[<h1 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h1><p>Python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。 </p>
<p>本文主要记录了在学习python过程中所遇到的一些小知识点。</p>
<a id="more"></a>
<!-- toc -->

<h2 id="1-str-和-repr-区别"><a href="#1-str-和-repr-区别" class="headerlink" title="1.__str__ 和__repr__区别"></a>1.<code>__str__</code> 和<code>__repr__</code>区别</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># __str__ 和 __repr__ 区别</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>__str__</code>用于为最终用户创建输出，而 <code>__repr__</code> 主要用于调试和开发。 <code>__repr__</code> 的目标是明确无误，<code>__str__</code>是可读的</li>
<li><code>__repr__</code> <a href="https://link.zhihu.com/?target=https%3A//docs.python.org/3/reference/datamodel.html%23object.__repr__">用于推断对象的”官方”字符串表示形式</a>（包含有关对象的所有信息的表示）, <code>__str__</code> <a href="https://link.zhihu.com/?target=https%3A//docs.python.org/3/reference/datamodel.html%23object.__str__">用于推断对象的“非正式”字符串表示形式</a>（对打印对象有用的表示形式）</li>
</ol>
<p>再通过一个例子说明问题:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">today = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> str(today)</span><br><span class="line"><span class="keyword">print</span> repr(today)</span><br></pre></td></tr></table></figure>

<p>输出结果如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(str(today))</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">52</span>:<span class="number">37.403320</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(today))</span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">16</span>, <span class="number">52</span>, <span class="number">37</span>, <span class="number">403320</span>)</span><br></pre></td></tr></table></figure>

<p><strong>当仅定义 <code>__repr__</code> 的时候， <code>__repr__</code> == <code>__str__</code>, 但是仅定义 <code>__str__</code> 的情况下，两者不相等。当两者均定义的时候，会各自使用自己的方法。</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/42730827" target="_blank" rel="noopener">上述详解</a></p>
<h2 id="2-init-和-new-关系"><a href="#2-init-和-new-关系" class="headerlink" title="2.__init__和__new__关系"></a>2.<code>__init__</code>和<code>__new__</code>关系</h2><p>python中有二个特殊的方法<code>__new__</code> 和 <code>__init__</code> 方法。<code>__init__</code> 方法为初始化方法, <code>__new__</code>方法才是真正的构造函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"in __new__"</span>)</span><br><span class="line">        instance = object.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        print(<span class="string">"in __init__"</span>)</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"Sheng"</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> __new__</span><br><span class="line"><span class="keyword">in</span> __init__</span><br></pre></td></tr></table></figure>

<p>上面的代码中实例化了一个Person对象，可以看到<code>__new__</code>和<code>__init__</code>都被调用了。<code>__new__</code>方法用于创建对象并返回对象，当返回对象时会自动调用<code>__init__</code>方法进行初始化。<code>__new__</code>方法是静态方法，而<code>__init__</code>是实例方法。</p>
<h2 id="3-python字典赋值新姿势"><a href="#3-python字典赋值新姿势" class="headerlink" title="3.python字典赋值新姿势"></a>3.python字典赋值新姿势</h2><p>平时字典的赋值是:test_dict = {“Name”:”Tom”}</p>
<p>下面的方法赋值时在后面添加了for语句，可提高字典的赋值效率，且代码更加简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line">person_tom = &#123;<span class="string">"name"</span>:<span class="string">"Tom"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line">person_jack = &#123;<span class="string">"name"</span>:<span class="string">"Jack"</span>,<span class="string">"age"</span>:<span class="number">20</span>&#125;</span><br><span class="line">person_list = (person_tom,person_jack)</span><br><span class="line">new_dict = &#123;indicators[<span class="string">"name"</span>]: indicators[<span class="string">"age"</span>]</span><br><span class="line">                          <span class="keyword">for</span> indicators <span class="keyword">in</span> person_list&#125;</span><br><span class="line">print(new_dict)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'Jack'</span>: <span class="number">20</span>, <span class="string">'Tom'</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<p>其次还有利用dict()快捷创建字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;dict()                        <span class="comment"># 创建空字典</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(a=<span class="string">'a'</span>, b=<span class="string">'b'</span>, t=<span class="string">'t'</span>)     <span class="comment"># 传入关键字</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="string">'a'</span>, <span class="string">'b'</span>: <span class="string">'b'</span>, <span class="string">'t'</span>: <span class="string">'t'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(zip([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))   <span class="comment"># 映射函数方式来构造字典</span></span><br><span class="line">&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'one'</span>: <span class="number">1</span>&#125; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict([(<span class="string">'one'</span>, <span class="number">1</span>), (<span class="string">'two'</span>, <span class="number">2</span>), (<span class="string">'three'</span>, <span class="number">3</span>)])    <span class="comment"># 可迭代对象方式来构造字典</span></span><br><span class="line">&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'one'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-格式化字符时多使用format函数"><a href="#4-格式化字符时多使用format函数" class="headerlink" title="4.格式化字符时多使用format函数"></a>4.格式化字符时多使用format函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bad</span></span><br><span class="line">name = <span class="string">"tony"</span></span><br><span class="line">age = <span class="number">100</span></span><br><span class="line">str = <span class="string">"myname : "</span> + name + <span class="string">" my age : "</span> + str(age)</span><br><span class="line">str1 = <span class="string">"myname : %s my age : %d"</span> % (name, age)</span><br><span class="line"><span class="comment"># good</span></span><br><span class="line">str2 = <span class="string">"myname : &#123;&#125; my age &#123;&#125;"</span>.format(name, age)</span><br></pre></td></tr></table></figure>

<p>示例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">"&#123;&#125; &#123;&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;1&#125; &#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'world hello world'</span></span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(name=<span class="string">"百度"</span>, url=<span class="string">"www.baidu.com"</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">"name"</span>: <span class="string">"百度"</span>, <span class="string">"url"</span>: <span class="string">"www.baidu.com"</span>&#125;</span><br><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(**site))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">'百度'</span>, <span class="string">'www.baidu.com'</span>]</span><br><span class="line">print(<span class="string">"网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;"</span>.format(my_list))  <span class="comment"># "0" 是必须的</span></span><br></pre></td></tr></table></figure>

<h2 id="5-使用enumerate代替for循环中的index变量访问"><a href="#5-使用enumerate代替for循环中的index变量访问" class="headerlink" title="5.使用enumerate代替for循环中的index变量访问"></a>5.使用enumerate代替for循环中的index变量访问</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bad</span></span><br><span class="line">my_container = [<span class="string">'lily'</span>, <span class="string">'lucy'</span>, <span class="string">'tom'</span>]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> my_container:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'&#123;&#125; &#123;&#125;'</span>.format(index, element)</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># good</span></span><br><span class="line"><span class="keyword">for</span> index, element <span class="keyword">in</span> enumerate(my_container):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%d %s'</span> % (index, element)</span><br></pre></td></tr></table></figure>

<h2 id="6-避免使用可变-mutable-变量作为函数参数的默认初始化值"><a href="#6-避免使用可变-mutable-变量作为函数参数的默认初始化值" class="headerlink" title="6.避免使用可变(mutable)变量作为函数参数的默认初始化值"></a>6.避免使用可变(mutable)变量作为函数参数的默认初始化值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bad</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(l = [])</span>:</span></span><br><span class="line"> l.append(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"> <span class="keyword">print</span> function()</span><br><span class="line"> <span class="keyword">print</span> function()</span><br><span class="line"> <span class="keyword">print</span> function()</span><br><span class="line"></span><br><span class="line"> <span class="comment"># print</span></span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"> <span class="comment"># good 使用None作为可变对象占位符</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(l=None)</span>:</span></span><br><span class="line">     <span class="keyword">if</span> l <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">         l = []</span><br><span class="line">     l.append(<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>

<h2 id="7-is-和-的区别"><a href="#7-is-和-的区别" class="headerlink" title="7.is 和 == 的区别"></a>7.is 和 == 的区别</h2><p><strong>is比较的是两个对象的id值是否相等，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址。</strong></p>
<p><strong>== 比较的是两个对象的内容是否相等，默认会调用对象的<code>__eq__()</code>方法。</strong></p>
<h3 id="哪些情况下is和-结果是完全相同的"><a href="#哪些情况下is和-结果是完全相同的" class="headerlink" title="哪些情况下is和==结果是完全相同的"></a>哪些情况下is和==结果是完全相同的</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">10</span>**<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么256时相同， 而1000时不同？</strong></p>
<p>因为出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把这些可能频繁使用的整数对象规定在范围[-5, 256]之间的小对象放在small_ints中，但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = <span class="string">'Hi'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1 = <span class="string">'Hi'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 <span class="keyword">is</span> b1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 == b1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 = <span class="string">'I am using long string for test'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = <span class="string">'I am using long string for test'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 <span class="keyword">is</span> b2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 == b2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么a1与b1相同，而a2与b2不同？</strong></p>
<p>这是python中的<strong>string interning（字符串驻留）</strong>机制所决定的：对于较小的字符串，为了提高系统性能会保留其值的一个副本，当创建新的字符串的时候直接指向该副本即可。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>当变量是数字、字符串、元组，列表，字典时，is和==都不相同， 不能互换使用！当比较值时，要使用==，比较是否是同一个内存地址时应该使用is。当然，开发中比较值的情况比较多。</p>
<h2 id="8-了解bytes、str与unicode的区别"><a href="#8-了解bytes、str与unicode的区别" class="headerlink" title="8.了解bytes、str与unicode的区别"></a>8.了解bytes、str与unicode的区别</h2><p>在<code>Python3</code>中，有两种类型的字符代表序列：<code>bytes(字节)</code>和 <code>str（字符串）</code>。字节的实例包含8个原生的比特值，而字符串的实例则是用Unicode字符来堆砌的。</p>
<p>在<code>Python2</code>中，有两种类型的字符代表序列：<code>str(字符串)</code> 和 <code>unicode(Unicode字符)</code>。与<code>Python3</code>相反，字符串实例代表着原生的8比特值序列，而<code>unicode</code>则由<code>Unicode</code>字符堆砌而成。</p>
<p>要想将<code>Unicode</code>字符转换成二进制数据，就必须使用<code>encode</code>方法，反过来，要想把二进制数据转换成<code>Unicode</code>字符，就必须使用<code>decode</code>方法。</p>
<p><strong>两大陷阱</strong></p>
<p>在<code>Python</code>中处理原生的8比特值 序列以及<code>Unicode</code>字符的时候，有两大陷阱。</p>
<p>一个是在<code>Python2</code>中，当一个<code>str</code>数据仅仅包含7比特的<code>ASCII</code>码字符的时候，<code>unicode</code>和<code>str</code>实例看起来是一致的。</p>
<ul>
<li>可以使用‘+’运算符和合并str和unicode。</li>
<li>可以使用等价或者不等价运算符来比较str和unicode实例。</li>
<li>可以使用unicode来代换 像‘%s’这种字符串中的格式化占位符。</li>
</ul>
<p>以上行为意味着，如果你的代码中仅仅处理原生的7比特序列，那么便可以不必在意是<code>str</code>类型的数据还是<code>unicode</code>类型的数据了。在<code>Python3</code>中，<code>bytes</code>和<code>str</code>实例是不可能等价的，即使是空的字符串也不可能等价。所以你必须谨慎地对正在处理的代码进行字符类别的区分处理。</p>
<p>另一个是在<code>Python3</code>中，涉及到文件处理的操作（使用内置的<code>open</code>函数）会默认的以<code>UTF-8</code>进行编码。而在<code>Python2</code>中默认采用二进制形式来编码。这也是导致意外事故发生的根源，特别是对于那些更习惯于使用<code>Python2</code>的程序员而言。</p>
<p>比方说，你想将几个随机的二进制数据写入到一个文件中。在<code>Python2</code>中，下面的这段代码可以正常的工作，但是在<code>Python3</code>中却会报错并退出。详细信息如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(<span class="string">'/tmp/random.bin'</span>,<span class="string">'w'</span>)</span> <span class="title">as</span> <span class="title">f</span>:</span></span><br><span class="line">    <span class="comment"># os.urandom() 随即产生n个字节的字符串，可以作为随机加密key使用</span></span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">TypeError: must be str,<span class="keyword">not</span> bytes</span><br></pre></td></tr></table></figure>

<p>导致这个异常发生的原因是在<code>Python3</code>中对于<code>open</code>函数又新增了一个名为<code>encoding</code>的参数。此参数默认为<code>UTF-8</code>。这使得其对于文件的读写操作预期的源为包含了<code>Unicode</code>字符串的<code>str</code>实例，而不是包含了二进制数据的字节文件。</p>
<p>为了使得上面的函数正常的工作，我们必须指明被操作的数据是以‘wb’模式打开，而不是简单的‘w’模式。这里，作者介绍了一个在<code>Python2</code>和<code>Python3</code> 中都通用的方法，详细如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>,<span class="string">'wb) as f:</span></span><br><span class="line"><span class="string">    f.write(os.urandom(10))</span></span><br></pre></td></tr></table></figure>

<p>好了，写文件的问题算是解决了，但是不要忘了还有读文件的问题哦。同样的我们也只需要改变一下读文件的模式即可。即‘r’换成‘rb’。</p>
<h2 id="9-python-星号"><a href="#9-python-星号" class="headerlink" title="9.python 星号"></a>9.python 星号</h2><p>在Python中，调用函数时，利用<code>*</code>语句可以将参数列表解包，如下所示，<code>foo</code>有两个参数，我们可以传入一个参数列表<code>num_list</code>，然后利用<code>*</code>运算符，解包参数列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(bar,lee)</span>:</span></span><br><span class="line">   ...:     <span class="keyword">print</span> bar, lee</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: num_list = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: foo(*num_list)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>序列解包</strong></p>
<p>在<strong>Python3.0</strong>之后，Python提供了一种非常方便的办法解压可迭代对象赋值给多个变量。</p>
<p>另外一种情况，假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。 你可以像下面这样分解这些记录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = (<span class="string">'Dave'</span>, <span class="string">'dave@example.com'</span>, <span class="string">'773-555-1212'</span>, <span class="string">'847-555-1212'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, email, *phone_numbers = record</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line"><span class="string">'Dave'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>email</span><br><span class="line"><span class="string">'dave@example.com'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phone_numbers</span><br><span class="line">[<span class="string">'773-555-1212'</span>, <span class="string">'847-555-1212'</span>]</span><br></pre></td></tr></table></figure>

<p>值得注意的是上面解压出的 <code>phone_numbers</code> 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 0 个）。 所以，任何使用到 <code>phone_numbers</code> 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了。</p>
<p>星号表达式也能用在列表的开始部分。比如，你有一个公司前 8 个月销售数据的序列， 但是你想看下最近一个月数据和前面 7 个月的平均值的对比。你可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*trailing_qtrs, current_qtr = sales_record</span><br><span class="line">trailing_avg = sum(trailing_qtrs) / len(trailing_qtrs)</span><br><span class="line"><span class="keyword">return</span> avg_comparison(trailing_avg, current_qtr)</span><br></pre></td></tr></table></figure>

<p>下面是在 Python 解释器中执行的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>*trailing, current = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trailing</span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>current</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在Python3中，也加入了一个新的语法（参见 <a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="noopener">PEP 3102</a>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg1, arg2, arg3, *, kwarg1, kwarg2)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这个函数只接受3个位置参数，<code>*</code>之后的所有内容只能作为关键字参数传递(只能由关键字提供的参数，并且永远不会被位置参数自动填充)。</p>
<p><a href="https://sikasjc.github.io/2018/10/12/star/" target="_blank" rel="noopener">更加详细相关内容请戳</a></p>
<h2 id="10-描述器"><a href="#10-描述器" class="headerlink" title="10.描述器"></a>10.描述器</h2><p>Python 有三个特殊方法，<code>__get__</code>、<code>__set__</code>、<code>__delete__</code>，用于覆盖属性的一些默认行为，如果一个类定义了其中一个方法，那么它的实例就是描述器</p>
<p>描述器是一种代理机制，对属性的操作由这个描述器来代理</p>
<p>访问: <code>__get__(self, instance, cls)</code> # instance 代表实例本身，cls 表示类本身，使用类直接访问时，instance 为 None</p>
<p>赋值: <code>__set__(self, instance, value)</code> # instance 为实例，value 为值</p>
<p>删除: <code>__delete__(self, instance)</code> # instance 为实例</p>
<p><a href="https://anyisalin.github.io/2017/03/08/python-descriptor/" target="_blank" rel="noopener">更加详细相关内容请戳</a></p>
<h2 id="11-Unicode码转中文输出"><a href="#11-Unicode码转中文输出" class="headerlink" title="11.Unicode码转中文输出"></a>11.Unicode码转中文输出</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unicode_str = <span class="string">"\u4e2d\u56fd"</span></span><br><span class="line"><span class="keyword">print</span> unicode_str.decode(<span class="string">"unicode-escape"</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">中国</span><br></pre></td></tr></table></figure>

<h2 id="12-将python对象保存到-bin文件"><a href="#12-将python对象保存到-bin文件" class="headerlink" title="12.将python对象保存到.bin文件"></a>12.将python对象保存到.bin文件</h2><p><a href="http://skyhigh233.com/blog/2016/11/18/effective-python-4/" target="_blank" rel="noopener">详细点击</a></p>
<p><strong>Effective Python 第44条</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf8-*-</span></span><br><span class="line"><span class="comment"># 该代码为自己写的测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将GameState实例化对象通过save()保存到game_data.bin</span></span><br><span class="line"><span class="comment"># 通过read()将game_data.bin内保存的实例化对象还原</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copyreg.pickle(GameState, pickle_game_state)的目的：</span></span><br><span class="line"><span class="comment"># 实例化对象保存到game_data.bin后，GameState加入新字段</span></span><br><span class="line"><span class="comment"># GameState加了新字段后，读取会读的到新字段，且新字段值为默认值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> copyreg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameState</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="number">0</span>, lives=<span class="number">3</span>, exp=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.level = level</span><br><span class="line">        self.lives = lives</span><br><span class="line">        self.exp = exp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path = <span class="string">"./game_data.bin"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">()</span>:</span></span><br><span class="line">    state = GameState()</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(state, f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        state_after = pickle.load(f)</span><br><span class="line">    <span class="keyword">print</span> state_after.__dict__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pickle_game_state</span><span class="params">(game_state)</span>:</span></span><br><span class="line">    kwargs = game_state.__dict__</span><br><span class="line">    <span class="keyword">return</span> unpickle_game_state, (kwargs,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpickle_game_state</span><span class="params">(kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> GameState(**kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># copyreg模块注册pickle_game_state</span></span><br><span class="line">    <span class="comment"># 目的是：GameState加了新字段后，读取会读的到新字段，且新字段值为默认值</span></span><br><span class="line">    copyreg.pickle(GameState, pickle_game_state)</span><br><span class="line">    <span class="comment"># save()</span></span><br><span class="line">    read()</span><br></pre></td></tr></table></figure>

<h2 id="13-python2和python3同时安装导致python3的pip报错解决"><a href="#13-python2和python3同时安装导致python3的pip报错解决" class="headerlink" title="13.python2和python3同时安装导致python3的pip报错解决"></a>13.python2和python3同时安装导致python3的pip报错解决</h2><p>原来只安装了python2.7。后来因为要用到python3，为了让两者共存，降python3的运行文件改成了python3.exe. 问题就此而来，这时候运行python3 的pip会遇到如下错误</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Fatal error <span class="keyword">in</span> launcher: Unable to create process using</span><br></pre></td></tr></table></figure>

<p>但是运行pip2是好的。如果这时候讲python2.7的运行文件改成Python2.exe，你就会发现pip2 也抛出了通用的错误。由此可以断定这个错误是因为改动了python的执行文件的名字造成的。</p>
<p>网上看了很多方案都说直接运行 python3 -m pip install –upgrade pip 来升级pip版本就好了，这个在大多数情况下都是有用的。因为重装以后会根据更改后的python的执行文件来创建关联。 但是如果你的pip已经是最新版本的话就行不通了，因为已经是最新的版本根本就不让你升级。那么就用下面的命令来强制重装 pip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3  -m pip install --upgrade --force-reinstall pip</span><br></pre></td></tr></table></figure>

<p>至此就解决了pip的错误。</p>
<h2 id="14-virtualenv-分别创建Python2和Python3的虚拟空间"><a href="#14-virtualenv-分别创建Python2和Python3的虚拟空间" class="headerlink" title="14.virtualenv 分别创建Python2和Python3的虚拟空间"></a>14.virtualenv 分别创建Python2和Python3的虚拟空间</h2><p>virtualenv是python开发中经常要用到的一个工具，如果在开发多个程序时候，A程序需要用python2.7，B程序需要python3时候，就可以利用virtualenv来创建一套独立的环境</p>
<p>接下来，在自己想要创建的目录中创建一个独立的python环境，</p>
<p>如果要创建<strong>python2</strong>的环境的话，命令为</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">virtualenv -p D:\Python\python.exe env2.<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>创建<strong>python3</strong>的环境命令如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virtualenv -p D:\python37\python3.exe env3<span class="number">.7</span></span><br></pre></td></tr></table></figure>

<p>以上路径需要替换为自己的python2和python3的安装路径。</p>
<p>如果要创建一个不带已经安装到系统的中第三方包的环境，可以加上参数 –no-site-packages，这样就可以得到一个不带任何第三方包的干净的python运行环境，命令为:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">virtualenv --no-site-packages myenv</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong>：</p>
<p><strong>进入虚拟环境</strong>：</p>
<p>在你的虚拟环境目录下的Scripts内<code>your_env_dir\Scripts</code>，输入<strong>activate</strong>即可在虚拟环境内开发。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">pyProject</span>\<span class="title">test</span>\<span class="title">test_virtualenv</span>\<span class="title">env3</span>.7\<span class="title">Scripts</span>&gt;<span class="title">activate</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">(<span class="title">env3</span>.7) <span class="title">D</span>:\<span class="title">pyProject</span>\<span class="title">test</span>\<span class="title">test_virtualenv</span>\<span class="title">env3</span>.7\<span class="title">Scripts</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>退出虚拟环境</strong>：</p>
<p>输入<strong>deactivate</strong>即可退出虚拟环境。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">(env3.<span class="number">7</span>) D:\pyProject\test\test_virtualenv\env3.<span class="number">7</span>\Scripts&gt;deactivate</span><br><span class="line"><span class="function">D:\<span class="title">pyProject</span>\<span class="title">test</span>\<span class="title">test_virtualenv</span>\<span class="title">env3</span>.7\<span class="title">Scripts</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>pycharm使用虚拟环境</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File --&gt; Settings --&gt; Project:your project name --&gt; Project Interpreter --&gt; 点击设置图标 --&gt; Add --&gt; System Interpreter --&gt; ...图标 --&gt; 选择虚拟环境目录\Scripts --&gt; 选择python.exe</span><br></pre></td></tr></table></figure>

<p>这样pycharm运行就会使用虚拟环境的python解释器以及虚拟环境内的第三方包。</p>
<p><strong>注意</strong>：</p>
<p>使用虚拟环境时，有个地方需要注意，那就是别移动环境目录，因为所有的路径（包括python3命令所指向的路径），都以硬编码的形式写在了安装目录之中，如果移动了，那么环境自然就会失效。为此我们可以将旧环境的依赖关系导出，然后创建新的环境。</p>
<p>导出环境：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>恢复环境：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 在requirements.txt所在目录下运行</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<h2 id="15-python取余运算与地板除"><a href="#15-python取余运算与地板除" class="headerlink" title="15.python取余运算与地板除"></a>15.python取余运算与地板除</h2><p>python中取余运算逻辑如下：</p>
<p>如果<em>a</em> 与<em>d</em> 是整数，<em>d</em> 非零，那么余数 <em>r</em> 满足这样的关系：</p>
<p>a = qd + r , q 为整数，且0 ≤ |r| &lt; |d|。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取余</span></span><br><span class="line">In [<span class="number">3</span>]: <span class="number">-53</span>%<span class="number">10</span></span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">7</span></span><br><span class="line"><span class="comment"># -53 = 10 * (-6) + 7</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 地板除</span></span><br><span class="line">In [<span class="number">2</span>]: <span class="number">-53</span>//<span class="number">10</span></span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">-6</span></span><br></pre></td></tr></table></figure>

<h2 id="16-windows-pip安装第三方包报错"><a href="#16-windows-pip安装第三方包报错" class="headerlink" title="16.windows pip安装第三方包报错"></a>16.windows pip安装第三方包报错</h2><p>报错如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">Exception:</span></span><br><span class="line"><span class="function"><span class="title">Traceback</span> (<span class="title">most</span> <span class="title">recent</span> <span class="title">call</span> <span class="title">last</span>):</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">basecommand.py</span>", <span class="title">line</span> 215, <span class="title">in</span> <span class="title">main</span></span></span><br><span class="line"><span class="function">    <span class="title">status</span> = <span class="title">self.run</span>(<span class="title">options</span>, <span class="title">args</span>)</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">commands</span>\<span class="title">install.py</span>", <span class="title">line</span> 324, <span class="title">in</span> <span class="title">run</span></span></span><br><span class="line"><span class="function">    <span class="title">requirement_set.prepare_files</span>(<span class="title">finder</span>)</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">req</span>\<span class="title">req_set.py</span>", <span class="title">line</span> 380, <span class="title">in</span> <span class="title">prepare_files</span></span></span><br><span class="line"><span class="function">    <span class="title">ignore_dependencies</span>=<span class="title">self.ignore_dependencies</span>))</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">req</span>\<span class="title">req_set.py</span>", <span class="title">line</span> 620, <span class="title">in</span> <span class="title">_prepare_file</span></span></span><br><span class="line"><span class="function">    <span class="title">session</span>=<span class="title">self.session</span>, <span class="title">hashes</span>=<span class="title">hashes</span>)</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">download.py</span>", <span class="title">line</span> 821, <span class="title">in</span> <span class="title">unpack_url</span></span></span><br><span class="line"><span class="function">    <span class="title">hashes</span>=<span class="title">hashes</span></span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">download.py</span>", <span class="title">line</span> 659, <span class="title">in</span> <span class="title">unpack_http_url</span></span></span><br><span class="line"><span class="function">    <span class="title">hashes</span>)</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">download.py</span>", <span class="title">line</span> 882, <span class="title">in</span> <span class="title">_download_http_url</span></span></span><br><span class="line"><span class="function">    <span class="title">_download_url</span>(<span class="title">resp</span>, <span class="title">link</span>, <span class="title">content_file</span>, <span class="title">hashes</span>)</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">download.py</span>", <span class="title">line</span> 603, <span class="title">in</span> <span class="title">_download_url</span></span></span><br><span class="line"><span class="function">    <span class="title">hashes.check_against_chunks</span>(<span class="title">downloaded_chunks</span>)</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">utils</span>\<span class="title">hashes.py</span>", <span class="title">line</span> 46, <span class="title">in</span> <span class="title">check_against_chunks</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="title">chunk</span> <span class="title">in</span> <span class="title">chunks</span>:</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">download.py</span>", <span class="title">line</span> 571, <span class="title">in</span> <span class="title">written_chunks</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="title">chunk</span> <span class="title">in</span> <span class="title">chunks</span>:</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">utils</span>\<span class="title">ui.py</span>", <span class="title">line</span> 139, <span class="title">in</span> <span class="title">iter</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="title">x</span> <span class="title">in</span> <span class="title">it</span>:</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">download.py</span>", <span class="title">line</span> 560, <span class="title">in</span> <span class="title">resp_read</span></span></span><br><span class="line"><span class="function">    <span class="title">decode_content</span>=<span class="title">False</span>):</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">_vendor</span>\<span class="title">urllib3</span>\<span class="title">response.py</span>", <span class="title">line</span> 436, <span class="title">in</span> <span class="title">stream</span></span></span><br><span class="line"><span class="function">    <span class="title">data</span> = <span class="title">self.read</span>(<span class="title">amt</span>=<span class="title">amt</span>, <span class="title">decode_content</span>=<span class="title">decode_content</span>)</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">_vendor</span>\<span class="title">urllib3</span>\<span class="title">response.py</span>", <span class="title">line</span> 401, <span class="title">in</span> <span class="title">read</span></span></span><br><span class="line"><span class="function">    <span class="title">raise</span> <span class="title">IncompleteRead</span>(<span class="title">self._fp_bytes_read</span>, <span class="title">self.length_remaining</span>)</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">contextlib.py</span>", <span class="title">line</span> 35, <span class="title">in</span> <span class="title">__exit__</span></span></span><br><span class="line"><span class="function">    <span class="title">self.gen.throw</span>(<span class="title">type</span>, <span class="title">value</span>, <span class="title">traceback</span>)</span></span><br><span class="line"><span class="function">  <span class="title">File</span> "<span class="title">d</span>:\<span class="title">python27</span>\<span class="title">lib</span>\<span class="title">site</span>-<span class="title">packages</span>\<span class="title">pip</span>\<span class="title">_vendor</span>\<span class="title">urllib3</span>\<span class="title">response.py</span>", <span class="title">line</span> 316, <span class="title">in</span> <span class="title">_error_catcher</span></span></span><br><span class="line"><span class="function">    <span class="title">raise</span> <span class="title">ReadTimeoutError</span>(<span class="title">self._pool</span>, <span class="title">None</span>, '<span class="title">Read</span> <span class="title">timed</span> <span class="title">out</span>.')</span></span><br><span class="line"><span class="function"><span class="title">ReadTimeoutError</span>: <span class="title">HTTPSConnectionPool</span>(<span class="title">host</span>='<span class="title">files.pythonhosted.org</span>', <span class="title">port</span>=443): <span class="title">Read</span> <span class="title">timed</span> <span class="title">out</span>.</span></span><br></pre></td></tr></table></figure>
<p>输入如下命令解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install --user package_name</span><br></pre></td></tr></table></figure>

<p> 参考：<a href="https://blog.csdn.net/stevenkwong/article/details/68489870" target="_blank" rel="noopener">https://blog.csdn.net/stevenkwong/article/details/68489870</a> </p>
<h2 id="17-python同类型名方法调用新姿势"><a href="#17-python同类型名方法调用新姿势" class="headerlink" title="17.python同类型名方法调用新姿势"></a>17.python同类型名方法调用新姿势</h2><p>若要调用很多方法名类似的方法，如hello_1,hello_2…等，可用如下方法调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"hello world!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello_python</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"hello python!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello_what</span><span class="params">(self, what)</span>:</span></span><br><span class="line">        data = <span class="string">f"hello <span class="subst">&#123;what&#125;</span>"</span></span><br><span class="line">        print(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello_self</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># class内调用本类方法也可以</span></span><br><span class="line">        list = [<span class="string">"world"</span>, <span class="string">"python"</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">            parameter = <span class="string">f"hello_<span class="subst">&#123;i&#125;</span>"</span></span><br><span class="line">            getattr(self, parameter)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    list = [<span class="string">"world"</span>, <span class="string">"python"</span>]</span><br><span class="line">    h = hello()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">        parameter = <span class="string">f"hello_<span class="subst">&#123;i&#125;</span>"</span></span><br><span class="line">        print(parameter)</span><br><span class="line">        getattr(h, parameter)()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 带参数方法调用</span></span><br><span class="line">    getattr(h, <span class="string">"hello_what"</span>)(<span class="string">"python 3.7"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"\n===================="</span>)</span><br><span class="line">    h.hello_self()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">hello_world</span><br><span class="line">hello world!</span><br><span class="line">hello_python</span><br><span class="line">hello python!</span><br><span class="line">hello python <span class="number">3.7</span></span><br><span class="line"></span><br><span class="line">====================</span><br><span class="line">hello world!</span><br><span class="line">hello python!</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python学习笔记</tag>
      </tags>
  </entry>
</search>
